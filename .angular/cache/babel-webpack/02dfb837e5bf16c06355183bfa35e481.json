{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Observable } from \"../../utilities/index.js\";\n\nvar OperationBatcher = function () {\n  function OperationBatcher(_a) {\n    var batchDebounce = _a.batchDebounce,\n        batchInterval = _a.batchInterval,\n        batchMax = _a.batchMax,\n        batchHandler = _a.batchHandler,\n        batchKey = _a.batchKey;\n    this.queuedRequests = new Map();\n    this.batchDebounce = batchDebounce;\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax || 0;\n    this.batchHandler = batchHandler;\n\n    this.batchKey = batchKey || function () {\n      return '';\n    };\n  }\n\n  OperationBatcher.prototype.enqueueRequest = function (request) {\n    var _this = this;\n\n    var requestCopy = __assign({}, request);\n\n    var queued = false;\n    var key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable(function (observer) {\n        if (!_this.queuedRequests.has(key)) {\n          _this.queuedRequests.set(key, []);\n        }\n\n        if (!queued) {\n          _this.queuedRequests.get(key).push(requestCopy);\n\n          queued = true;\n        }\n\n        requestCopy.next = requestCopy.next || [];\n        if (observer.next) requestCopy.next.push(observer.next.bind(observer));\n        requestCopy.error = requestCopy.error || [];\n        if (observer.error) requestCopy.error.push(observer.error.bind(observer));\n        requestCopy.complete = requestCopy.complete || [];\n        if (observer.complete) requestCopy.complete.push(observer.complete.bind(observer));\n\n        if (_this.queuedRequests.get(key).length === 1) {\n          _this.scheduleQueueConsumption(key);\n        } else if (_this.batchDebounce) {\n          clearTimeout(_this.scheduledBatchTimer);\n\n          _this.scheduleQueueConsumption(key);\n        }\n\n        if (_this.queuedRequests.get(key).length === _this.batchMax) {\n          _this.consumeQueue(key);\n        }\n      });\n    }\n\n    return requestCopy.observable;\n  };\n\n  OperationBatcher.prototype.consumeQueue = function (key) {\n    var requestKey = key || '';\n    var queuedRequests = this.queuedRequests.get(requestKey);\n\n    if (!queuedRequests) {\n      return;\n    }\n\n    this.queuedRequests.delete(requestKey);\n    var requests = queuedRequests.map(function (queuedRequest) {\n      return queuedRequest.operation;\n    });\n    var forwards = queuedRequests.map(function (queuedRequest) {\n      return queuedRequest.forward;\n    });\n    var observables = [];\n    var nexts = [];\n    var errors = [];\n    var completes = [];\n    queuedRequests.forEach(function (batchableRequest, index) {\n      observables.push(batchableRequest.observable);\n      nexts.push(batchableRequest.next);\n      errors.push(batchableRequest.error);\n      completes.push(batchableRequest.complete);\n    });\n    var batchedObservable = this.batchHandler(requests, forwards) || Observable.of();\n\n    var onError = function (error) {\n      errors.forEach(function (rejecters) {\n        if (rejecters) {\n          rejecters.forEach(function (e) {\n            return e(error);\n          });\n        }\n      });\n    };\n\n    batchedObservable.subscribe({\n      next: function (results) {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          var error = new Error(\"server returned results with length \".concat(results.length, \", expected length of \").concat(nexts.length));\n          error.result = results;\n          return onError(error);\n        }\n\n        results.forEach(function (result, index) {\n          if (nexts[index]) {\n            nexts[index].forEach(function (next) {\n              return next(result);\n            });\n          }\n        });\n      },\n      error: onError,\n      complete: function () {\n        completes.forEach(function (complete) {\n          if (complete) {\n            complete.forEach(function (c) {\n              return c();\n            });\n          }\n        });\n      }\n    });\n    return observables;\n  };\n\n  OperationBatcher.prototype.scheduleQueueConsumption = function (key) {\n    var _this = this;\n\n    var requestKey = key || '';\n    this.scheduledBatchTimer = setTimeout(function () {\n      if (_this.queuedRequests.get(requestKey) && _this.queuedRequests.get(requestKey).length) {\n        _this.consumeQueue(requestKey);\n      }\n    }, this.batchInterval);\n  };\n\n  return OperationBatcher;\n}();\n\nexport { OperationBatcher }; //# sourceMappingURL=batching.js.map","map":null,"metadata":{},"sourceType":"module"}