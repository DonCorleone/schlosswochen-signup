{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpClient } from '@angular/common/http';\nimport { ApolloLink, Observable as Observable$1 } from '@apollo/client/core';\nimport { print } from 'graphql';\nimport { extractFiles } from 'extract-files';\nimport { Observable } from 'rxjs';\nimport { BatchLink } from '@apollo/client/link/batch';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common/http';\n\nconst fetch = (req, httpClient, extractFiles) => {\n  const shouldUseBody = ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;\n\n  const shouldStringify = param => ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1;\n\n  const isBatching = req.body.length;\n  let shouldUseMultipart = req.options && req.options.useMultipart;\n  let multipartInfo;\n\n  if (shouldUseMultipart) {\n    if (isBatching) {\n      return new Observable(observer => observer.error(new Error('File upload is not available when combined with Batching')));\n    }\n\n    if (!shouldUseBody) {\n      return new Observable(observer => observer.error(new Error('File upload is not available when GET is used')));\n    }\n\n    multipartInfo = extractFiles(req.body);\n    shouldUseMultipart = !!multipartInfo.files.size;\n  } // `body` for some, `params` for others\n\n\n  let bodyOrParams = {};\n\n  if (isBatching) {\n    if (!shouldUseBody) {\n      return new Observable(observer => observer.error(new Error('Batching is not available for GET requests')));\n    }\n\n    bodyOrParams = {\n      body: req.body\n    };\n  } else {\n    const body = shouldUseMultipart ? multipartInfo.clone : req.body;\n\n    if (shouldUseBody) {\n      bodyOrParams = {\n        body\n      };\n    } else {\n      const params = Object.keys(req.body).reduce((obj, param) => {\n        const value = req.body[param];\n        obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;\n        return obj;\n      }, {});\n      bodyOrParams = {\n        params: params\n      };\n    }\n  }\n\n  if (shouldUseMultipart && shouldUseBody) {\n    const form = new FormData();\n    form.append('operations', JSON.stringify(bodyOrParams.body));\n    const map = {};\n    const files = multipartInfo.files;\n    let i = 0;\n    files.forEach(paths => {\n      map[++i] = paths;\n    });\n    form.append('map', JSON.stringify(map));\n    i = 0;\n    files.forEach((_, file) => {\n      form.append(++i + '', file, file.name);\n    });\n    bodyOrParams.body = form;\n  } // create a request\n\n\n  return httpClient.request(req.method, req.url, Object.assign(Object.assign({\n    observe: 'response',\n    responseType: 'json',\n    reportProgress: false\n  }, bodyOrParams), req.options));\n};\n\nconst mergeHeaders = (source, destination) => {\n  if (source && destination) {\n    const merged = destination.keys().reduce((headers, name) => headers.set(name, destination.getAll(name)), source);\n    return merged;\n  }\n\n  return destination || source;\n};\n\nfunction prioritize(...values) {\n  const picked = values.find(val => typeof val !== 'undefined');\n\n  if (typeof picked === 'undefined') {\n    return values[values.length - 1];\n  }\n\n  return picked;\n}\n\nfunction createHeadersWithClientAwereness(context) {\n  // `apollographql-client-*` headers are automatically set if a\n  // `clientAwareness` object is found in the context. These headers are\n  // set first, followed by the rest of the headers pulled from\n  // `context.headers`.\n  let headers = context.headers && context.headers instanceof HttpHeaders ? context.headers : new HttpHeaders(context.headers);\n\n  if (context.clientAwareness) {\n    const {\n      name,\n      version\n    } = context.clientAwareness; // If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n\n    if (name && !headers.has('apollographql-client-name')) {\n      headers = headers.set('apollographql-client-name', name);\n    }\n\n    if (version && !headers.has('apollographql-client-version')) {\n      headers = headers.set('apollographql-client-version', version);\n    }\n  }\n\n  return headers;\n} // XXX find a better name for it\n\n\nclass HttpLinkHandler extends ApolloLink {\n  constructor(httpClient, options) {\n    super();\n    this.httpClient = httpClient;\n    this.options = options;\n    this.print = print;\n\n    if (this.options.operationPrinter) {\n      this.print = this.options.operationPrinter;\n    }\n\n    this.requester = operation => new Observable$1(observer => {\n      const context = operation.getContext(); // decides which value to pick, Context, Options or to just use the default\n\n      const pick = (key, init) => {\n        return prioritize(context[key], this.options[key], init);\n      };\n\n      const includeQuery = pick('includeQuery', true);\n      const includeExtensions = pick('includeExtensions', false);\n      const method = pick('method', 'POST');\n      const url = pick('uri', 'graphql');\n      const withCredentials = pick('withCredentials');\n      const useMultipart = pick('useMultipart');\n      const req = {\n        method,\n        url: typeof url === 'function' ? url(operation) : url,\n        body: {\n          operationName: operation.operationName,\n          variables: operation.variables\n        },\n        options: {\n          withCredentials,\n          useMultipart,\n          headers: this.options.headers\n        }\n      };\n\n      if (includeExtensions) {\n        req.body.extensions = operation.extensions;\n      }\n\n      if (includeQuery) {\n        req.body.query = this.print(operation.query);\n      }\n\n      const headers = createHeadersWithClientAwereness(context);\n      req.options.headers = mergeHeaders(req.options.headers, headers);\n      const sub = fetch(req, this.httpClient, extractFiles).subscribe({\n        next: response => {\n          operation.setContext({\n            response\n          });\n          observer.next(response.body);\n        },\n        error: err => observer.error(err),\n        complete: () => observer.complete()\n      });\n      return () => {\n        if (!sub.closed) {\n          sub.unsubscribe();\n        }\n      };\n    });\n  }\n\n  request(op) {\n    return this.requester(op);\n  }\n\n}\n\nlet HttpLink = /*#__PURE__*/(() => {\n  class HttpLink {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n    }\n\n    create(options) {\n      return new HttpLinkHandler(this.httpClient, options);\n    }\n\n  }\n\n  HttpLink.ɵfac = function HttpLink_Factory(t) {\n    return new (t || HttpLink)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient));\n  };\n\n  HttpLink.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function HttpLink_Factory() {\n      return new HttpLink(i0.ɵɵinject(i1.HttpClient));\n    },\n    token: HttpLink,\n    providedIn: \"root\"\n  });\n  return HttpLink;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst defaults = {\n  batchInterval: 10,\n  batchMax: 10,\n  uri: 'graphql',\n  method: 'POST'\n};\n\nclass HttpBatchLinkHandler extends ApolloLink {\n  constructor(httpClient, options) {\n    super();\n    this.httpClient = httpClient;\n    this.options = options;\n    this.print = print;\n    this.batchInterval = options.batchInterval || defaults.batchInterval;\n    this.batchMax = options.batchMax || defaults.batchMax;\n\n    if (this.options.operationPrinter) {\n      this.print = this.options.operationPrinter;\n    }\n\n    const batchHandler = operations => {\n      return new Observable$1(observer => {\n        const body = this.createBody(operations);\n        const headers = this.createHeaders(operations);\n        const {\n          method,\n          uri,\n          withCredentials\n        } = this.createOptions(operations);\n\n        if (typeof uri === 'function') {\n          throw new Error(`Option 'uri' is a function, should be a string`);\n        }\n\n        const req = {\n          method,\n          url: uri,\n          body: body,\n          options: {\n            withCredentials,\n            headers\n          }\n        };\n        const sub = fetch(req, this.httpClient, () => {\n          throw new Error('File upload is not available when combined with Batching');\n        }).subscribe({\n          next: result => observer.next(result.body),\n          error: err => observer.error(err),\n          complete: () => observer.complete()\n        });\n        return () => {\n          if (!sub.closed) {\n            sub.unsubscribe();\n          }\n        };\n      });\n    };\n\n    const batchKey = options.batchKey || (operation => {\n      return this.createBatchKey(operation);\n    });\n\n    this.batcher = new BatchLink({\n      batchInterval: this.batchInterval,\n      batchMax: this.batchMax,\n      batchKey,\n      batchHandler\n    });\n  }\n\n  createOptions(operations) {\n    const context = operations[0].getContext();\n    return {\n      method: prioritize(context.method, this.options.method, defaults.method),\n      uri: prioritize(context.uri, this.options.uri, defaults.uri),\n      withCredentials: prioritize(context.withCredentials, this.options.withCredentials)\n    };\n  }\n\n  createBody(operations) {\n    return operations.map(operation => {\n      const includeExtensions = prioritize(operation.getContext().includeExtensions, this.options.includeExtensions, false);\n      const includeQuery = prioritize(operation.getContext().includeQuery, this.options.includeQuery, true);\n      const body = {\n        operationName: operation.operationName,\n        variables: operation.variables\n      };\n\n      if (includeExtensions) {\n        body.extensions = operation.extensions;\n      }\n\n      if (includeQuery) {\n        body.query = this.print(operation.query);\n      }\n\n      return body;\n    });\n  }\n\n  createHeaders(operations) {\n    var _a, _b;\n\n    return operations.reduce((headers, operation) => {\n      return mergeHeaders(headers, operation.getContext().headers);\n    }, createHeadersWithClientAwereness({\n      headers: this.options.headers,\n      clientAwareness: (_b = (_a = operations[0]) === null || _a === void 0 ? void 0 : _a.getContext()) === null || _b === void 0 ? void 0 : _b.clientAwareness\n    }));\n  }\n\n  createBatchKey(operation) {\n    const context = operation.getContext();\n\n    if (context.skipBatching) {\n      return Math.random().toString(36).substr(2, 9);\n    }\n\n    const headers = context.headers && context.headers.keys().map(k => context.headers.get(k));\n    const opts = JSON.stringify({\n      includeQuery: context.includeQuery,\n      includeExtensions: context.includeExtensions,\n      headers\n    });\n    return prioritize(context.uri, this.options.uri) + opts;\n  }\n\n  request(op) {\n    return this.batcher.request(op);\n  }\n\n}\n\nlet HttpBatchLink = /*#__PURE__*/(() => {\n  class HttpBatchLink {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n    }\n\n    create(options) {\n      return new HttpBatchLinkHandler(this.httpClient, options);\n    }\n\n  }\n\n  HttpBatchLink.ɵfac = function HttpBatchLink_Factory(t) {\n    return new (t || HttpBatchLink)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient));\n  };\n\n  HttpBatchLink.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function HttpBatchLink_Factory() {\n      return new HttpBatchLink(i0.ɵɵinject(i1.HttpClient));\n    },\n    token: HttpBatchLink,\n    providedIn: \"root\"\n  });\n  return HttpBatchLink;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // http\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { HttpBatchLink, HttpBatchLinkHandler, HttpLink, HttpLinkHandler }; //# sourceMappingURL=ngApolloLinkHttp.js.map","map":null,"metadata":{},"sourceType":"module"}