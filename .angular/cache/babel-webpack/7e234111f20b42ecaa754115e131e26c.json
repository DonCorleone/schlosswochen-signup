{"ast":null,"code":"import _asyncToGenerator from \"/Users/dev/Documents/Projects/Schlosswochen-Inscription/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/dev/Documents/Projects/Schlosswochen-Inscription/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/dev/Documents/Projects/Schlosswochen-Inscription/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/dev/Documents/Projects/Schlosswochen-Inscription/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { EJSON, ObjectId } from 'bson';\nimport * as bson from 'bson';\nexport { bson as BSON };\n\nvar __spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nvar BrowserInfo =\n/** @class */\nfunction () {\n  function BrowserInfo(name, version, os) {\n    this.name = name;\n    this.version = version;\n    this.os = os;\n    this.type = 'browser';\n  }\n\n  return BrowserInfo;\n}();\n\nvar NodeInfo =\n/** @class */\nfunction () {\n  function NodeInfo(version) {\n    this.version = version;\n    this.type = 'node';\n    this.name = 'node';\n    this.os = process.platform;\n  }\n\n  return NodeInfo;\n}();\n\nvar SearchBotDeviceInfo =\n/** @class */\nfunction () {\n  function SearchBotDeviceInfo(name, version, os, bot) {\n    this.name = name;\n    this.version = version;\n    this.os = os;\n    this.bot = bot;\n    this.type = 'bot-device';\n  }\n\n  return SearchBotDeviceInfo;\n}();\n\nvar BotInfo =\n/** @class */\nfunction () {\n  function BotInfo() {\n    this.type = 'bot';\n    this.bot = true; // NOTE: deprecated test name instead\n\n    this.name = 'bot';\n    this.version = null;\n    this.os = null;\n  }\n\n  return BotInfo;\n}();\n\nvar ReactNativeInfo =\n/** @class */\nfunction () {\n  function ReactNativeInfo() {\n    this.type = 'react-native';\n    this.name = 'react-native';\n    this.version = null;\n    this.os = null;\n  }\n\n  return ReactNativeInfo;\n}(); // tslint:disable-next-line:max-line-length\n\n\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [['aol', /AOLShield\\/([0-9\\._]+)/], ['edge', /Edge\\/([0-9\\._]+)/], ['edge-ios', /EdgiOS\\/([0-9\\._]+)/], ['yandexbrowser', /YaBrowser\\/([0-9\\._]+)/], ['kakaotalk', /KAKAOTALK\\s([0-9\\.]+)/], ['samsung', /SamsungBrowser\\/([0-9\\.]+)/], ['silk', /\\bSilk\\/([0-9._-]+)\\b/], ['miui', /MiuiBrowser\\/([0-9\\.]+)$/], ['beaker', /BeakerBrowser\\/([0-9\\.]+)/], ['edge-chromium', /Edg\\/([0-9\\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], ['phantomjs', /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/], ['crios', /CriOS\\/([0-9\\.]+)(:?\\s|$)/], ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/], ['fxios', /FxiOS\\/([0-9\\.]+)/], ['opera-mini', /Opera Mini.*Version\\/([0-9\\.]+)/], ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)/], ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/], ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], ['ie', /MSIE\\s(7\\.0)/], ['bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/], ['android', /Android\\s([0-9\\.]+)/], ['ios', /Version\\/([0-9\\._]+).*Mobile.*Safari.*/], ['safari', /Version\\/([0-9\\._]+).*Safari/], ['facebook', /FBAV\\/([0-9\\.]+)/], ['instagram', /Instagram\\s([0-9\\.]+)/], ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Mobile/], ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/], ['searchbot', SEARCHBOX_UA_REGEX]];\nvar operatingSystemRules = [['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Chrome OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\\/2/]];\n\nfunction detect(userAgent) {\n  if (!!userAgent) {\n    return parseUserAgent(userAgent);\n  }\n\n  if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return new ReactNativeInfo();\n  }\n\n  if (typeof navigator !== 'undefined') {\n    return parseUserAgent(navigator.userAgent);\n  }\n\n  return getNodeVersion();\n}\n\nfunction matchUserAgent(ua) {\n  // opted for using reduce here rather than Array#first with a regex.test call\n  // this is primarily because using the reduce we only perform the regex\n  // execution once rather than once for the test and for the exec again below\n  // probably something that needs to be benchmarked though\n  return ua !== '' && userAgentRules.reduce(function (matched, _a) {\n    var browser = _a[0],\n        regex = _a[1];\n\n    if (matched) {\n      return matched;\n    }\n\n    var uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser, uaMatch];\n  }, false);\n}\n\nfunction parseUserAgent(ua) {\n  var matchedRule = matchUserAgent(ua);\n\n  if (!matchedRule) {\n    return null;\n  }\n\n  var name = matchedRule[0],\n      match = matchedRule[1];\n\n  if (name === 'searchbot') {\n    return new BotInfo();\n  }\n\n  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);\n\n  if (versionParts) {\n    if (versionParts.length < REQUIRED_VERSION_PARTS) {\n      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));\n    }\n  } else {\n    versionParts = [];\n  }\n\n  var version = versionParts.join('.');\n  var os = detectOS(ua);\n  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);\n\n  if (searchBotMatch && searchBotMatch[1]) {\n    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);\n  }\n\n  return new BrowserInfo(name, version, os);\n}\n\nfunction detectOS(ua) {\n  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n    var _a = operatingSystemRules[ii],\n        os = _a[0],\n        regex = _a[1];\n    var match = regex.exec(ua);\n\n    if (match) {\n      return os;\n    }\n  }\n\n  return null;\n}\n\nfunction getNodeVersion() {\n  var isNode = typeof process !== 'undefined' && process.version;\n  return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\n\nfunction createVersionParts(count) {\n  var output = [];\n\n  for (var ii = 0; ii < count; ii++) {\n    output.push('0');\n  }\n\n  return output;\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n\nclass DefaultNetworkTransport {\n  constructor() {\n    if (!DefaultNetworkTransport.fetch) {\n      throw new Error(\"DefaultNetworkTransport.fetch must be set before it's used\");\n    }\n\n    if (!DefaultNetworkTransport.AbortController) {\n      throw new Error(\"DefaultNetworkTransport.AbortController must be set before it's used\");\n    }\n  }\n\n  fetchWithCallbacks(request, handler) {\n    // tslint:disable-next-line: no-console\n    this.fetch(request).then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (response) {\n        const decodedBody = yield response.text(); // Pull out the headers of the response\n\n        const responseHeaders = {};\n        response.headers.forEach((value, key) => {\n          responseHeaders[key] = value;\n        });\n        return {\n          statusCode: response.status,\n          headers: responseHeaders,\n          body: decodedBody\n        };\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()).then(r => handler.onSuccess(r)).catch(e => handler.onError(e));\n  }\n\n  fetch(request) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        timeoutMs,\n        url,\n        ...rest\n      } = request;\n\n      const {\n        signal,\n        cancelTimeout\n      } = _this2.createTimeoutSignal(timeoutMs);\n\n      try {\n        // We'll await the response to catch throw our own error\n        return yield DefaultNetworkTransport.fetch(url, {\n          signal,\n          ...rest\n        });\n      } finally {\n        // Whatever happens, cancel any timeout\n        cancelTimeout();\n      }\n    })();\n  }\n\n  createTimeoutSignal(timeoutMs) {\n    if (typeof timeoutMs === \"number\") {\n      const controller = new DefaultNetworkTransport.AbortController(); // Call abort after a specific number of milliseconds\n\n      const timeout = setTimeout(() => {\n        controller.abort();\n      }, timeoutMs);\n      return {\n        signal: controller.signal,\n        cancelTimeout: () => {\n          clearTimeout(timeout);\n        }\n      };\n    } else {\n      return {\n        signal: undefined,\n        cancelTimeout: () => {\n          /* No-op */\n        }\n      };\n    }\n  }\n\n}\n\nDefaultNetworkTransport.DEFAULT_HEADERS = {\n  \"Content-Type\": \"application/json\"\n}; ////////////////////////////////////////////////////////////////////////////\n\nDefaultNetworkTransport.fetch = window.fetch.bind(window);\nDefaultNetworkTransport.AbortController = window.AbortController;\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n    }\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar base64 = createCommonjsModule(function (module, exports) {\n  (function (global, factory) {\n    module.exports = factory(global);\n  })(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal, function (global) {\n    // existing version for noConflict()\n    global = global || {};\n    var _Base64 = global.Base64;\n    var version = \"2.6.4\"; // constants\n\n    var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    var b64tab = function (bin) {\n      var t = {};\n\n      for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n\n      return t;\n    }(b64chars);\n\n    var fromCharCode = String.fromCharCode; // encoder stuff\n\n    var cb_utob = function (c) {\n      if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n      } else {\n        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);\n        return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n      }\n    };\n\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n\n    var utob = function (u) {\n      return u.replace(re_utob, cb_utob);\n    };\n\n    var cb_encode = function (ccc) {\n      var padlen = [0, 2, 1][ccc.length % 3],\n          ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),\n          chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];\n      return chars.join('');\n    };\n\n    var btoa = global.btoa && typeof global.btoa == 'function' ? function (b) {\n      return global.btoa(b);\n    } : function (b) {\n      if (b.match(/[^\\x00-\\xFF]/)) throw new RangeError('The string contains invalid characters.');\n      return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n\n    var _encode = function (u) {\n      return btoa(utob(String(u)));\n    };\n\n    var mkUriSafe = function (b64) {\n      return b64.replace(/[+\\/]/g, function (m0) {\n        return m0 == '+' ? '-' : '_';\n      }).replace(/=/g, '');\n    };\n\n    var encode = function (u, urisafe) {\n      return urisafe ? mkUriSafe(_encode(u)) : _encode(u);\n    };\n\n    var encodeURI = function (u) {\n      return encode(u, true);\n    };\n\n    var fromUint8Array;\n    if (global.Uint8Array) fromUint8Array = function (a, urisafe) {\n      // return btoa(fromCharCode.apply(null, a));\n      var b64 = '';\n\n      for (var i = 0, l = a.length; i < l; i += 3) {\n        var a0 = a[i],\n            a1 = a[i + 1],\n            a2 = a[i + 2];\n        var ord = a0 << 16 | a1 << 8 | a2;\n        b64 += b64chars.charAt(ord >>> 18) + b64chars.charAt(ord >>> 12 & 63) + (typeof a1 != 'undefined' ? b64chars.charAt(ord >>> 6 & 63) : '=') + (typeof a2 != 'undefined' ? b64chars.charAt(ord & 63) : '=');\n      }\n\n      return urisafe ? mkUriSafe(b64) : b64;\n    }; // decoder stuff\n\n    var re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n\n    var cb_btou = function (cccc) {\n      switch (cccc.length) {\n        case 4:\n          var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),\n              offset = cp - 0x10000;\n          return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);\n\n        case 3:\n          return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));\n\n        default:\n          return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));\n      }\n    };\n\n    var btou = function (b) {\n      return b.replace(re_btou, cb_btou);\n    };\n\n    var cb_decode = function (cccc) {\n      var len = cccc.length,\n          padlen = len % 4,\n          n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),\n          chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];\n      chars.length -= [0, 0, 2, 1][padlen];\n      return chars.join('');\n    };\n\n    var _atob = global.atob && typeof global.atob == 'function' ? function (a) {\n      return global.atob(a);\n    } : function (a) {\n      return a.replace(/\\S{1,4}/g, cb_decode);\n    };\n\n    var atob = function (a) {\n      return _atob(String(a).replace(/[^A-Za-z0-9\\+\\/]/g, ''));\n    };\n\n    var _decode = function (a) {\n      return btou(_atob(a));\n    };\n\n    var _fromURI = function (a) {\n      return String(a).replace(/[-_]/g, function (m0) {\n        return m0 == '-' ? '+' : '/';\n      }).replace(/[^A-Za-z0-9\\+\\/]/g, '');\n    };\n\n    var decode = function (a) {\n      return _decode(_fromURI(a));\n    };\n\n    var toUint8Array;\n    if (global.Uint8Array) toUint8Array = function (a) {\n      return Uint8Array.from(atob(_fromURI(a)), function (c) {\n        return c.charCodeAt(0);\n      });\n    };\n\n    var noConflict = function () {\n      var Base64 = global.Base64;\n      global.Base64 = _Base64;\n      return Base64;\n    }; // export Base64\n\n\n    global.Base64 = {\n      VERSION: version,\n      atob: atob,\n      btoa: btoa,\n      fromBase64: decode,\n      toBase64: encode,\n      utob: utob,\n      encode: encode,\n      encodeURI: encodeURI,\n      btou: btou,\n      decode: decode,\n      noConflict: noConflict,\n      fromUint8Array: fromUint8Array,\n      toUint8Array: toUint8Array\n    }; // if ES5 is available, make Base64.extendString() available\n\n    if (typeof Object.defineProperty === 'function') {\n      var noEnum = function (v) {\n        return {\n          value: v,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        };\n      };\n\n      global.Base64.extendString = function () {\n        Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () {\n          return decode(this);\n        }));\n        Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) {\n          return encode(this, urisafe);\n        }));\n        Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () {\n          return encode(this, true);\n        }));\n      };\n    } //\n    // export Base64 to the namespace\n    //\n\n\n    if (global['Meteor']) {\n      // Meteor.js\n      Base64 = global.Base64;\n    } // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n\n\n    if (module.exports) {\n      module.exports.Base64 = global.Base64;\n    } // that's it!\n\n\n    return {\n      Base64: global.Base64\n    };\n  });\n}); ////////////////////////////////////////////////////////////////////////////\n\nconst SERIALIZATION_OPTIONS = {\n  relaxed: false\n};\n/**\n * Serialize an object containing BSON types into extended-JSON.\n *\n * @param obj The object containing BSON types.\n * @returns The document in extended-JSON format.\n */\n\nfunction serialize(obj) {\n  return EJSON.serialize(obj, SERIALIZATION_OPTIONS);\n}\n/**\n * De-serialize an object or an array of object from extended-JSON into an object or an array of object with BSON types.\n *\n * @param obj The object or array of objects in extended-JSON format.\n * @returns The object or array of objects with inflated BSON types.\n */\n\n\nfunction deserialize(obj) {\n  if (Array.isArray(obj)) {\n    return obj.map(doc => EJSON.deserialize(doc));\n  } else {\n    return EJSON.deserialize(obj);\n  }\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * The type of a user.\n */\n\n\nvar UserType = /*#__PURE__*/(() => {\n  (function (UserType) {\n    /**\n     * A normal end-user created this user.\n     */\n    UserType[\"Normal\"] = \"normal\";\n    /**\n     * The user was created by the server.\n     */\n\n    UserType[\"Server\"] = \"server\";\n  })(UserType || (UserType = {}));\n\n  return UserType;\n})();\n\n/** @ignore */\nvar DataKey = /*#__PURE__*/(() => {\n  (function (DataKey) {\n    /** @ignore */\n    DataKey[\"NAME\"] = \"name\";\n    /** @ignore */\n\n    DataKey[\"EMAIL\"] = \"email\";\n    /** @ignore */\n\n    DataKey[\"PICTURE\"] = \"picture\";\n    /** @ignore */\n\n    DataKey[\"FIRST_NAME\"] = \"first_name\";\n    /** @ignore */\n\n    DataKey[\"LAST_NAME\"] = \"last_name\";\n    /** @ignore */\n\n    DataKey[\"GENDER\"] = \"gender\";\n    /** @ignore */\n\n    DataKey[\"BIRTHDAY\"] = \"birthday\";\n    /** @ignore */\n\n    DataKey[\"MIN_AGE\"] = \"min_age\";\n    /** @ignore */\n\n    DataKey[\"MAX_AGE\"] = \"max_age\";\n  })(DataKey || (DataKey = {}));\n\n  return DataKey;\n})();\nconst DATA_MAPPING = {\n  [DataKey.NAME]: \"name\",\n  [DataKey.EMAIL]: \"email\",\n  [DataKey.PICTURE]: \"pictureUrl\",\n  [DataKey.FIRST_NAME]: \"firstName\",\n  [DataKey.LAST_NAME]: \"lastName\",\n  [DataKey.GENDER]: \"gender\",\n  [DataKey.BIRTHDAY]: \"birthday\",\n  [DataKey.MIN_AGE]: \"minAge\",\n  [DataKey.MAX_AGE]: \"maxAge\"\n};\n/** @inheritdoc */\n\nclass UserProfile {\n  /**\n   * @param response The response of a call fetching the users profile.\n   */\n  constructor(response) {\n    /** @ignore */\n    this.type = UserType.Normal;\n    /** @ignore */\n\n    this.identities = [];\n\n    if (typeof response === \"object\" && response !== null) {\n      const {\n        type,\n        identities,\n        data\n      } = response;\n\n      if (typeof type === \"string\") {\n        this.type = type;\n      } else {\n        throw new Error(\"Expected 'type' in the response body\");\n      }\n\n      if (Array.isArray(identities)) {\n        this.identities = identities.map(identity => {\n          return {\n            id: identity.id,\n            providerType: identity[\"provider_type\"]\n          };\n        });\n      } else {\n        throw new Error(\"Expected 'identities' in the response body\");\n      }\n\n      if (typeof data === \"object\" && data !== null) {\n        const mappedData = Object.fromEntries(Object.entries(data).map(([key, value]) => {\n          if (key in DATA_MAPPING) {\n            // Translate any known data field to its JS idiomatic alias\n            return [DATA_MAPPING[key], value];\n          } else {\n            // Pass through any other values\n            return [key, value];\n          }\n        })); // We can use `any` since we trust the user supplies the correct type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        this.data = deserialize(mappedData);\n      } else {\n        throw new Error(\"Expected 'data' in the response body\");\n      }\n    } else {\n      this.data = {};\n    }\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n/**\n * A `Storage` which will prefix a key part to every operation.\n */\n\n\nlet PrefixedStorage = /*#__PURE__*/(() => {\n  class PrefixedStorage {\n    /**\n     * Construct a `Storage` which will prefix a key part to every operation.\n     *\n     * @param storage The underlying storage to use for operations.\n     * @param keyPart The part of the key to prefix when performing operations.\n     */\n    constructor(storage, keyPart) {\n      this.storage = storage;\n      this.keyPart = keyPart;\n    }\n    /** @inheritdoc */\n\n\n    get(key) {\n      return this.storage.get(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);\n    }\n    /** @inheritdoc */\n\n\n    set(key, value) {\n      return this.storage.set(this.keyPart + PrefixedStorage.PART_SEPARATOR + key, value);\n    }\n    /** @inheritdoc */\n\n\n    remove(key) {\n      return this.storage.remove(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);\n    }\n    /** @inheritdoc */\n\n\n    prefix(keyPart) {\n      return new PrefixedStorage(this, keyPart);\n    }\n    /** @inheritdoc */\n\n\n    clear(prefix = \"\") {\n      return this.storage.clear(this.keyPart + PrefixedStorage.PART_SEPARATOR + prefix);\n    }\n    /** @inheritdoc */\n\n\n    addListener(listener) {\n      return this.storage.addListener(listener);\n    }\n    /** @inheritdoc */\n\n\n    removeListener(listener) {\n      return this.storage.addListener(listener);\n    }\n\n  }\n\n  /**\n   * The string separating two parts.\n   */\n  PrefixedStorage.PART_SEPARATOR = \":\"; ////////////////////////////////////////////////////////////////////////////\n\n  return PrefixedStorage;\n})();\nconst ACCESS_TOKEN_STORAGE_KEY = \"accessToken\";\nconst REFRESH_TOKEN_STORAGE_KEY = \"refreshToken\";\nconst PROFILE_STORAGE_KEY = \"profile\";\nconst PROVIDER_TYPE_STORAGE_KEY = \"providerType\";\n/**\n * Storage specific to the app.\n */\n\nclass UserStorage extends PrefixedStorage {\n  /**\n   * Construct a storage for a `User`.\n   *\n   * @param storage The underlying storage to wrap.\n   * @param userId The id of the user.\n   */\n  constructor(storage, userId) {\n    super(storage, `user(${userId})`);\n  }\n  /**\n   * Get the access token from storage.\n   *\n   * @returns Access token (null if unknown).\n   */\n\n\n  get accessToken() {\n    return this.get(ACCESS_TOKEN_STORAGE_KEY);\n  }\n  /**\n   * Set the access token in storage.\n   *\n   * @param value Access token (null if unknown).\n   */\n\n\n  set accessToken(value) {\n    if (value === null) {\n      this.remove(ACCESS_TOKEN_STORAGE_KEY);\n    } else {\n      this.set(ACCESS_TOKEN_STORAGE_KEY, value);\n    }\n  }\n  /**\n   * Get the refresh token from storage.\n   *\n   * @returns Refresh token (null if unknown and user is logged out).\n   */\n\n\n  get refreshToken() {\n    return this.get(REFRESH_TOKEN_STORAGE_KEY);\n  }\n  /**\n   * Set the refresh token in storage.\n   *\n   * @param value Refresh token (null if unknown and user is logged out).\n   */\n\n\n  set refreshToken(value) {\n    if (value === null) {\n      this.remove(REFRESH_TOKEN_STORAGE_KEY);\n    } else {\n      this.set(REFRESH_TOKEN_STORAGE_KEY, value);\n    }\n  }\n  /**\n   * Get the user profile from storage.\n   *\n   * @returns User profile (undefined if its unknown).\n   */\n\n\n  get profile() {\n    const value = this.get(PROFILE_STORAGE_KEY);\n\n    if (value) {\n      const profile = new UserProfile(); // Patch in the values\n\n      Object.assign(profile, JSON.parse(value));\n      return profile;\n    }\n  }\n  /**\n   * Set the user profile in storage.\n   *\n   * @param value User profile (undefined if its unknown).\n   */\n\n\n  set profile(value) {\n    if (value) {\n      this.set(PROFILE_STORAGE_KEY, JSON.stringify(value));\n    } else {\n      this.remove(PROFILE_STORAGE_KEY);\n    }\n  }\n  /**\n   * Get the type of authentication provider used to authenticate\n   *\n   * @returns User profile (undefined if its unknown).\n   */\n\n\n  get providerType() {\n    const value = this.get(PROVIDER_TYPE_STORAGE_KEY);\n\n    if (value) {\n      return value;\n    }\n  }\n  /**\n   * Set the type of authentication provider used to authenticate\n   *\n   * @param value Type of authentication provider.\n   */\n\n\n  set providerType(value) {\n    if (value) {\n      this.set(PROVIDER_TYPE_STORAGE_KEY, value);\n    } else {\n      this.remove(PROVIDER_TYPE_STORAGE_KEY);\n    }\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n/**\n * @param obj The object to remove keys (and undefined values from)\n * @returns A new object without the keys where the value is undefined.\n */\n\n\nfunction removeKeysWithUndefinedValues(obj) {\n  return Object.fromEntries(Object.entries(obj).filter(entry => typeof entry[1] !== \"undefined\"));\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * Generate a random sequence of characters.\n *\n * @param length The length of the string.\n * @param alphabet The alphabet of characters to pick from.\n * @returns A string of characters picked randomly from `alphabet`.\n */\n\n\nfunction generateRandomString(length, alphabet) {\n  let result = \"\";\n\n  for (let i = 0; i < length; i++) {\n    result += alphabet[Math.floor(Math.random() * alphabet.length)];\n  }\n\n  return result;\n}\n/**\n * Encode an object mapping from string to string, into a query string to be appended a URL.\n *\n * @param params The parameters to include in the string.\n * @param prefixed Should the \"?\" prefix be added if values exists?\n * @returns A URL encoded representation of the parameters (omitting a \"?\" prefix).\n */\n\n\nfunction encodeQueryString(params, prefixed = true) {\n  // Filter out undefined values\n  const cleanedParams = removeKeysWithUndefinedValues(params); // Determine if a prefixed \"?\" is appropreate\n\n  const prefix = prefixed && Object.keys(cleanedParams).length > 0 ? \"?\" : \"\"; // Transform keys and values to a query string\n\n  return prefix + Object.entries(cleanedParams).map(([k, v]) => `${k}=${encodeURIComponent(v)}`).join(\"&\");\n}\n/**\n * Decodes a query string into an object.\n *\n * @param str The query string to decode.\n * @returns The decoded query string.\n */\n\n\nfunction decodeQueryString(str) {\n  const cleanStr = str[0] === \"?\" ? str.substr(1) : str;\n  return Object.fromEntries(cleanStr.split(\"&\").filter(s => s.length > 0).map(kvp => kvp.split(\"=\")).map(([k, v]) => [k, decodeURIComponent(v)]));\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * A list of names that functions cannot have to be callable through the functions proxy.\n */\n\n\nconst RESERVED_NAMES = [\"inspect\", \"callFunction\", \"callFunctionStreaming\", // Methods defined on the Object.prototype might be \"typeof probed\" and called by libraries and runtime environments.\n...Object.getOwnPropertyNames(Object.prototype)];\n/**\n * Remove the key for any fields with undefined values.\n *\n * @param args The arguments to clean.\n * @returns The cleaned arguments.\n */\n\nfunction cleanArgs(args) {\n  for (const arg of args) {\n    if (typeof arg === \"object\") {\n      for (const [key, value] of Object.entries(arg)) {\n        if (value === undefined) {\n          delete arg[key];\n        }\n      }\n    }\n  }\n\n  return args;\n}\n/**\n * Remove keys for any undefined values and serialize to EJSON.\n *\n * @param args The arguments to clean and serialize.\n * @returns The cleaned and serialized arguments.\n */\n\n\nfunction cleanArgsAndSerialize(args) {\n  const cleaned = cleanArgs(args);\n  return cleaned.map(arg => typeof arg === \"object\" ? serialize(arg) : arg);\n}\n/**\n * Defines how functions are called.\n */\n\n\nclass FunctionsFactory {\n  /**\n   * @param fetcher The underlying fetcher to use when sending requests.\n   * @param config Additional configuration parameters.\n   */\n  constructor(fetcher, config = {}) {\n    this.fetcher = fetcher;\n    this.serviceName = config.serviceName;\n    this.argsTransformation = config.argsTransformation || cleanArgsAndSerialize;\n  }\n  /**\n   * Create a factory of functions, wrapped in a Proxy that returns bound copies of `callFunction` on any property.\n   *\n   * @param fetcher The underlying fetcher to use when requesting.\n   * @param config Additional configuration parameters.\n   * @returns The newly created factory of functions.\n   */\n\n\n  static create(fetcher, config = {}) {\n    // Create a proxy, wrapping a simple object returning methods that calls functions\n    // TODO: Lazily fetch available functions and return these from the ownKeys() trap\n    const factory = new FunctionsFactory(fetcher, config); // Wrap the factory in a proxy that calls the internal call method\n\n    return new Proxy(factory, {\n      get(target, p, receiver) {\n        if (typeof p === \"string\" && RESERVED_NAMES.indexOf(p) === -1) {\n          return target.callFunction.bind(target, p);\n        } else {\n          const prop = Reflect.get(target, p, receiver);\n          return typeof prop === \"function\" ? prop.bind(target) : prop;\n        }\n      }\n\n    });\n  }\n  /**\n   * Call a remote function by it's name.\n   *\n   * @param name Name of the remote function.\n   * @param args Arguments to pass to the remote function.\n   * @returns A promise of the value returned when executing the remote function.\n   */\n\n\n  callFunction(name, ...args) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // See https://github.com/mongodb/stitch-js-sdk/blob/master/packages/core/sdk/src/services/internal/CoreStitchServiceClientImpl.ts\n      const body = {\n        name,\n        arguments: _this3.argsTransformation ? _this3.argsTransformation(args) : args\n      };\n\n      if (_this3.serviceName) {\n        body.service = _this3.serviceName;\n      }\n\n      const appRoute = _this3.fetcher.appRoute;\n      return _this3.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.functionsCall().path,\n        body\n      });\n    })();\n  }\n  /**\n   * Call a remote function by it's name.\n   *\n   * @param name Name of the remote function.\n   * @param args Arguments to pass to the remote function.\n   * @returns A promise of the value returned when executing the remote function.\n   */\n\n\n  callFunctionStreaming(name, ...args) {\n    const body = {\n      name,\n      arguments: this.argsTransformation ? this.argsTransformation(args) : args\n    };\n\n    if (this.serviceName) {\n      body.service = this.serviceName;\n    }\n\n    const appRoute = this.fetcher.appRoute;\n    const qs = encodeQueryString({\n      [\"baas_request\"]: Base64.encode(JSON.stringify(body))\n    });\n    return this.fetcher.fetchStream({\n      method: \"GET\",\n      path: appRoute.functionsCall().path + qs\n    });\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n/** @inheritdoc */\n\n\nclass EmailPasswordAuth {\n  /**\n   * Construct an interface to the email / password authentication provider.\n   *\n   * @param fetcher The underlying fetcher used to request the services.\n   * @param providerName Optional custom name of the authentication provider.\n   */\n  constructor(fetcher, providerName = \"local-userpass\") {\n    this.fetcher = fetcher;\n    this.providerName = providerName;\n  }\n  /** @inheritdoc */\n\n\n  registerUser(email, password) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const appRoute = _this4.fetcher.appRoute;\n      yield _this4.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.emailPasswordAuth(_this4.providerName).register().path,\n        body: {\n          email,\n          password\n        }\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  confirmUser(token, tokenId) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const appRoute = _this5.fetcher.appRoute;\n      yield _this5.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.emailPasswordAuth(_this5.providerName).confirm().path,\n        body: {\n          token,\n          tokenId\n        }\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  resendConfirmationEmail(email) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const appRoute = _this6.fetcher.appRoute;\n      yield _this6.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.emailPasswordAuth(_this6.providerName).confirmSend().path,\n        body: {\n          email\n        }\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  resetPassword(token, tokenId, password) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const appRoute = _this7.fetcher.appRoute;\n      yield _this7.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.emailPasswordAuth(_this7.providerName).reset().path,\n        body: {\n          token,\n          tokenId,\n          password\n        }\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  sendResetPasswordEmail(email) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const appRoute = _this8.fetcher.appRoute;\n      yield _this8.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.emailPasswordAuth(_this8.providerName).resetSend().path,\n        body: {\n          email\n        }\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  callResetPasswordFunction(email, password, ...args) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const appRoute = _this9.fetcher.appRoute;\n      yield _this9.fetcher.fetchJSON({\n        method: \"POST\",\n        path: appRoute.emailPasswordAuth(_this9.providerName).resetCall().path,\n        body: {\n          email,\n          password,\n          arguments: args\n        }\n      });\n    })();\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n/**\n * @returns The base api route.\n */\n\n\nfunction api() {\n  return {\n    path: \"/api/client/v2.0\",\n\n    /**\n     * @param appId The id of the app.\n     * @returns The URL of the app endpoint.\n     */\n    app(appId) {\n      return {\n        path: this.path + `/app/${appId}`,\n\n        /**\n         * @returns The URL of the app location endpoint.\n         */\n        location() {\n          return {\n            path: this.path + \"/location\"\n          };\n        },\n\n        /**\n         * @param providerName The name of the provider.\n         * @returns The app url concatinated with the /auth/providers/{providerName}\n         */\n        authProvider(providerName) {\n          return {\n            path: this.path + `/auth/providers/${providerName}`,\n\n            /**\n             * @returns Get the URL of an authentication provider.\n             */\n            login() {\n              return {\n                path: this.path + \"/login\"\n              };\n            }\n\n          };\n        },\n\n        /**\n         * @param providerName The name of the provider.\n         * @returns The app url concatinated with the /auth/providers/{providerName}\n         */\n        emailPasswordAuth(providerName) {\n          const authProviderRoutes = this.authProvider(providerName);\n          return { ...authProviderRoutes,\n\n            register() {\n              return {\n                path: this.path + \"/register\"\n              };\n            },\n\n            confirm() {\n              return {\n                path: this.path + \"/confirm\"\n              };\n            },\n\n            confirmSend() {\n              return {\n                path: this.path + \"/confirm/send\"\n              };\n            },\n\n            reset() {\n              return {\n                path: this.path + \"/reset\"\n              };\n            },\n\n            resetSend() {\n              return {\n                path: this.path + \"/reset/send\"\n              };\n            },\n\n            resetCall() {\n              return {\n                path: this.path + \"/reset/call\"\n              };\n            }\n\n          };\n        },\n\n        functionsCall() {\n          return {\n            path: this.path + \"/functions/call\"\n          };\n        }\n\n      };\n    },\n\n    auth() {\n      return {\n        path: this.path + \"/auth\",\n\n        apiKeys() {\n          return {\n            path: this.path + \"/api_keys\",\n\n            key(id) {\n              return {\n                path: this.path + `/${id}`,\n\n                enable() {\n                  return {\n                    path: this.path + \"/enable\"\n                  };\n                },\n\n                disable() {\n                  return {\n                    path: this.path + \"/disable\"\n                  };\n                }\n\n              };\n            }\n\n          };\n        },\n\n        profile() {\n          return {\n            path: this.path + \"/profile\"\n          };\n        },\n\n        session() {\n          return {\n            path: this.path + \"/session\"\n          };\n        }\n\n      };\n    }\n\n  };\n}\n\nvar routes = {\n  api\n}; ////////////////////////////////////////////////////////////////////////////\n\n/** @inheritdoc */\n\nclass ApiKeyAuth {\n  /**\n   * Construct an interface to the API-key authentication provider.\n   *\n   * @param fetcher The fetcher used to send requests to services.\n   * @param providerName Optional custom name of the authentication provider.\n   */\n  constructor(fetcher, providerName = \"api-key\") {\n    this.fetcher = fetcher;\n  }\n  /** @inheritdoc */\n\n\n  create(name) {\n    return this.fetcher.fetchJSON({\n      method: \"POST\",\n      body: {\n        name\n      },\n      path: routes.api().auth().apiKeys().path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n\n\n  fetch(keyId) {\n    return this.fetcher.fetchJSON({\n      method: \"GET\",\n      path: routes.api().auth().apiKeys().key(keyId).path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n\n\n  fetchAll() {\n    return this.fetcher.fetchJSON({\n      method: \"GET\",\n      tokenType: \"refresh\",\n      path: routes.api().auth().apiKeys().path\n    });\n  }\n  /** @inheritdoc */\n\n\n  delete(keyId) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this10.fetcher.fetchJSON({\n        method: \"DELETE\",\n        path: routes.api().auth().apiKeys().key(keyId).path,\n        tokenType: \"refresh\"\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  enable(keyId) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this11.fetcher.fetchJSON({\n        method: \"PUT\",\n        path: routes.api().auth().apiKeys().key(keyId).enable().path,\n        tokenType: \"refresh\"\n      });\n    })();\n  }\n  /** @inheritdoc */\n\n\n  disable(keyId) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this12.fetcher.fetchJSON({\n        method: \"PUT\",\n        path: routes.api().auth().apiKeys().key(keyId).disable().path,\n        tokenType: \"refresh\"\n      });\n    })();\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n\nlet environment = null;\n/**\n * Set the environment of execution.\n * Note: This should be called as the first thing before executing any code which calls getEnvironment()\n *\n * @param e An object containing environment specific implementations.\n */\n\nfunction setEnvironment(e) {\n  environment = e;\n}\n/**\n * Get the environment of execution.\n *\n * @returns An object containing environment specific implementations.\n */\n\n\nfunction getEnvironment() {\n  if (environment) {\n    return environment;\n  } else {\n    throw new Error(\"Cannot get environment before it's set\");\n  }\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n/**\n * An error occured during the parsing of a watch stream.\n */\n\n\nclass WatchError extends Error {\n  constructor({\n    message,\n    code\n  }) {\n    super(message);\n    /**\n     * The name of this type of error\n     */\n\n    this.name = \"WatchError\";\n    this.code = code;\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n// NOTE: this is a fully processed event, not a single \"data: foo\" line!\n\n/**\n * The state of a WatchStream.\n */\n\n\nvar WatchStreamState = /*#__PURE__*/(() => {\n  (function (WatchStreamState) {\n    /**\n     * Need to call one of the feed functions.\n     */\n    WatchStreamState[\"NEED_DATA\"] = \"NEED_DATA\";\n    /**\n     * Call nextEvent() to consume an event.\n     */\n\n    WatchStreamState[\"HAVE_EVENT\"] = \"HAVE_EVENT\";\n    /**\n     * Call error().\n     */\n\n    WatchStreamState[\"HAVE_ERROR\"] = \"HAVE_ERROR\";\n  })(WatchStreamState || (WatchStreamState = {}));\n\n  return WatchStreamState;\n})();\n\n/**\n * Represents a stream of events\n */\nclass WatchStream {\n  constructor() {\n    this._state = WatchStreamState.NEED_DATA;\n    this._error = null; // Used by feedBuffer to construct lines\n\n    this._textDecoder = new (getEnvironment().TextDecoder)();\n    this._buffer = \"\";\n    this._bufferOffset = 0; // Used by feedLine for building the next SSE\n\n    this._eventType = \"\";\n    this._dataBuffer = \"\";\n  } // Call these when you have data, in whatever shape is easiest for your SDK to get.\n  // Pick one, mixing and matching on a single instance isn't supported.\n  // These can only be called in NEED_DATA state, which is the initial state.\n\n\n  feedBuffer(buffer) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    this._buffer += this._textDecoder.decode(buffer, {\n      stream: true\n    });\n    this.advanceBufferState();\n  }\n\n  feedLine(line) {\n    this.assertState(WatchStreamState.NEED_DATA); // This is an implementation of the algorithm described at\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation.\n    // Currently the server does not use id or retry lines, so that processing isn't implemented.\n    // ignore trailing LF if not removed by SDK.\n\n    if (line.endsWith(\"\\n\")) line = line.substr(0, line.length - 1); // ignore trailing CR from CRLF\n\n    if (line.endsWith(\"\\r\")) line = line.substr(0, line.length - 1);\n\n    if (line.length === 0) {\n      // This is the \"dispatch the event\" portion of the algorithm.\n      if (this._dataBuffer.length === 0) {\n        this._eventType = \"\";\n        return;\n      }\n\n      if (this._dataBuffer.endsWith(\"\\n\")) this._dataBuffer = this._dataBuffer.substr(0, this._dataBuffer.length - 1);\n      this.feedSse({\n        data: this._dataBuffer,\n        eventType: this._eventType\n      });\n      this._dataBuffer = \"\";\n      this._eventType = \"\";\n    }\n\n    if (line[0] === \":\") return;\n    const colon = line.indexOf(\":\");\n    const field = line.substr(0, colon);\n    let value = colon === -1 ? \"\" : line.substr(colon + 1);\n    if (value.startsWith(\" \")) value = value.substr(1);\n\n    if (field === \"event\") {\n      this._eventType = value;\n    } else if (field === \"data\") {\n      this._dataBuffer += value;\n      this._dataBuffer += \"\\n\";\n    } else ;\n  }\n\n  feedSse(sse) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    const firstPercentIndex = sse.data.indexOf(\"%\");\n\n    if (firstPercentIndex !== -1) {\n      // For some reason, the stich server decided to add percent-encoding for '%', '\\n', and '\\r' to its\n      // event-stream replies. But it isn't real urlencoding, since most characters pass through, so we can't use\n      // uri_percent_decode() here.\n      let buffer = \"\";\n      let start = 0;\n\n      for (let percentIndex = firstPercentIndex; percentIndex !== -1; percentIndex = sse.data.indexOf(\"%\", start)) {\n        buffer += sse.data.substr(start, percentIndex - start);\n        const encoded = sse.data.substr(percentIndex, 3); // may be smaller than 3 if string ends with %\n\n        if (encoded === \"%25\") {\n          buffer += \"%\";\n        } else if (encoded === \"%0A\") {\n          buffer += \"\\x0A\"; // '\\n'\n        } else if (encoded === \"%0D\") {\n          buffer += \"\\x0D\"; // '\\r'\n        } else {\n          buffer += encoded; // propagate as-is\n        }\n\n        start = percentIndex + encoded.length;\n      } // Advance the buffer with the last part\n\n\n      buffer += sse.data.substr(start);\n      sse.data = buffer;\n    }\n\n    if (!sse.eventType || sse.eventType === \"message\") {\n      try {\n        const parsed = EJSON.parse(sse.data);\n\n        if (typeof parsed === \"object\") {\n          // ???\n          this._nextEvent = parsed;\n          this._state = WatchStreamState.HAVE_EVENT;\n          return;\n        }\n      } catch {// fallthrough to same handling as for non-document value.\n      }\n\n      this._state = WatchStreamState.HAVE_ERROR;\n      this._error = new WatchError({\n        message: \"server returned malformed event: \" + sse.data,\n        code: \"bad bson parse\"\n      });\n    } else if (sse.eventType === \"error\") {\n      this._state = WatchStreamState.HAVE_ERROR; // default error message if we have issues parsing the reply.\n\n      this._error = new WatchError({\n        message: sse.data,\n        code: \"unknown\"\n      });\n\n      try {\n        const {\n          error_code: errorCode,\n          error\n        } = EJSON.parse(sse.data);\n        if (typeof errorCode !== \"string\") return;\n        if (typeof error !== \"string\") return; // XXX in realm-js, object-store will error if the error_code is not one of the known\n        // error code enum values.\n\n        this._error = new WatchError({\n          message: error,\n          code: errorCode\n        });\n      } catch {\n        return; // Use the default state.\n      }\n    } else ;\n  }\n\n  get state() {\n    return this._state;\n  } // Consumes the returned event. If you used feedBuffer(), there may be another event or error after this one,\n  // so you need to call state() again to see what to do next.\n\n\n  nextEvent() {\n    this.assertState(WatchStreamState.HAVE_EVENT); // We can use \"as ChangeEvent<T>\" since we just asserted the state.\n\n    const out = this._nextEvent;\n    this._state = WatchStreamState.NEED_DATA;\n    this.advanceBufferState();\n    return out;\n  } // Once this enters the error state, it stays that way. You should not feed any more data.\n\n\n  get error() {\n    return this._error;\n  } ////////////////////////////////////////////\n\n\n  advanceBufferState() {\n    this.assertState(WatchStreamState.NEED_DATA);\n\n    while (this.state === WatchStreamState.NEED_DATA) {\n      if (this._bufferOffset === this._buffer.length) {\n        this._buffer = \"\";\n        this._bufferOffset = 0;\n        return;\n      } // NOTE not supporting CR-only newlines, just LF and CRLF.\n\n\n      const nextNewlineIndex = this._buffer.indexOf(\"\\n\", this._bufferOffset);\n\n      if (nextNewlineIndex === -1) {\n        // We have a partial line.\n        if (this._bufferOffset !== 0) {\n          // Slide the partial line down to the front of the buffer.\n          this._buffer = this._buffer.substr(this._bufferOffset, this._buffer.length - this._bufferOffset);\n          this._bufferOffset = 0;\n        }\n\n        return;\n      }\n\n      this.feedLine(this._buffer.substr(this._bufferOffset, nextNewlineIndex - this._bufferOffset));\n      this._bufferOffset = nextNewlineIndex + 1; // Advance past this line, including its newline.\n    }\n  }\n\n  assertState(state) {\n    if (this._state !== state) {\n      throw Error(`Expected WatchStream to be in state ${state}, but in state ${this._state}`);\n    }\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * A remote collection of documents.\n */\n\n\nclass MongoDBCollection {\n  /**\n   * Construct a remote collection of documents.\n   *\n   * @param fetcher The fetcher to use when requesting the service.\n   * @param serviceName The name of the remote service.\n   * @param databaseName The name of the database.\n   * @param collectionName The name of the remote collection.\n   */\n  constructor(fetcher, serviceName, databaseName, collectionName) {\n    this.functions = FunctionsFactory.create(fetcher, {\n      serviceName\n    });\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.serviceName = serviceName;\n    this.fetcher = fetcher;\n  }\n  /** @inheritdoc */\n\n\n  find(filter = {}, options = {}) {\n    return this.functions.find({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      project: options.projection,\n      sort: options.sort,\n      limit: options.limit\n    });\n  }\n  /** @inheritdoc */\n\n\n  findOne(filter = {}, options = {}) {\n    return this.functions.findOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      project: options.projection,\n      sort: options.sort\n    });\n  }\n  /** @inheritdoc */\n\n\n  findOneAndUpdate(filter = {}, update, options = {}) {\n    return this.functions.findOneAndUpdate({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      update,\n      sort: options.sort,\n      projection: options.projection,\n      upsert: options.upsert,\n      returnNewDocument: options.returnNewDocument\n    });\n  }\n  /** @inheritdoc */\n\n\n  findOneAndReplace(filter = {}, replacement, options = {}) {\n    return this.functions.findOneAndReplace({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter: filter,\n      update: replacement,\n      sort: options.sort,\n      projection: options.projection,\n      upsert: options.upsert,\n      returnNewDocument: options.returnNewDocument\n    });\n  }\n  /** @inheritdoc */\n\n\n  findOneAndDelete(filter = {}, options = {}) {\n    return this.functions.findOneAndReplace({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      sort: options.sort,\n      projection: options.projection\n    });\n  }\n  /** @inheritdoc */\n\n\n  aggregate(pipeline) {\n    return this.functions.aggregate({\n      database: this.databaseName,\n      collection: this.collectionName,\n      pipeline\n    });\n  }\n  /** @inheritdoc */\n\n\n  count(filter = {}, options = {}) {\n    return this.functions.count({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      limit: options.limit\n    });\n  }\n  /** @inheritdoc */\n\n\n  insertOne(document) {\n    return this.functions.insertOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      document\n    });\n  }\n  /** @inheritdoc */\n\n\n  insertMany(documents) {\n    return this.functions.insertMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      documents\n    });\n  }\n  /** @inheritdoc */\n\n\n  deleteOne(filter = {}) {\n    return this.functions.deleteOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter\n    });\n  }\n  /** @inheritdoc */\n\n\n  deleteMany(filter = {}) {\n    return this.functions.deleteMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter\n    });\n  }\n  /** @inheritdoc */\n\n\n  updateOne(filter, update, options = {}) {\n    return this.functions.updateOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      update,\n      upsert: options.upsert\n    });\n  }\n  /** @inheritdoc */\n\n\n  updateMany(filter, update, options = {}) {\n    return this.functions.updateMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      update,\n      upsert: options.upsert\n    });\n  }\n\n  watch({\n    ids,\n    filter\n  } = {}) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const iterator = yield _awaitAsyncGenerator(_this.functions.callFunctionStreaming(\"watch\", {\n        database: _this.databaseName,\n        collection: _this.collectionName,\n        ids,\n        filter\n      }));\n      const watchStream = new WatchStream();\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(iterator), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          if (!chunk) continue;\n          watchStream.feedBuffer(chunk);\n\n          while (watchStream.state == WatchStreamState.HAVE_EVENT) {\n            yield watchStream.nextEvent();\n          }\n\n          if (watchStream.state == WatchStreamState.HAVE_ERROR) // XXX this is just throwing an error like {error_code: \"BadRequest, error: \"message\"},\n            // which matches realm-js, but is different from how errors are handled in realm-web\n            throw watchStream.error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates an Remote MongoDB Collection.\n * Note: This method exists to enable function binding.\n *\n * @param fetcher The underlying fetcher.\n * @param serviceName A service name.\n * @param databaseName A database name.\n * @param collectionName A collection name.\n * @returns The collection.\n */\n\n\nfunction createCollection(fetcher, serviceName, databaseName, collectionName) {\n  return new MongoDBCollection(fetcher, serviceName, databaseName, collectionName);\n}\n/**\n * Creates a Remote MongoDB Database.\n * Note: This method exists to enable function binding.\n *\n * @param fetcher The underlying fetcher\n * @param serviceName A service name\n * @param databaseName A database name\n * @returns The database.\n */\n\n\nfunction createDatabase(fetcher, serviceName, databaseName) {\n  return {\n    collection: createCollection.bind(null, fetcher, serviceName, databaseName)\n  };\n}\n/**\n * Creates a Remote MongoDB Service.\n * Note: This method exists to enable function binding.\n *\n * @param fetcher The underlying fetcher.\n * @param serviceName An optional service name.\n * @returns The service.\n */\n\n\nfunction createService(fetcher, serviceName = \"mongo-db\") {\n  return {\n    db: createDatabase.bind(null, fetcher, serviceName)\n  };\n} ////////////////////////////////////////////////////////////////////////////\n\n\nconst DEFAULT_DEVICE_ID = \"000000000000000000000000\";\n/** The state of a user within the app */\n\nvar UserState = /*#__PURE__*/(() => {\n  (function (UserState) {\n    /** Active, with both access and refresh tokens */\n    UserState[\"Active\"] = \"active\";\n    /** Logged out, but there might still be data persisted about the user, in the browser. */\n\n    UserState[\"LoggedOut\"] = \"logged-out\";\n    /** Logged out and all data about the user has been removed. */\n\n    UserState[\"Removed\"] = \"removed\";\n  })(UserState || (UserState = {}));\n\n  return UserState;\n})();\n\n/** The type of a user. */\nvar UserType$1 = /*#__PURE__*/(() => {\n  (function (UserType) {\n    /** Created by the user itself. */\n    UserType[\"Normal\"] = \"normal\";\n    /** Created by an administrator of the app. */\n\n    UserType[\"Server\"] = \"server\";\n  })(UserType$1 || (UserType$1 = {}));\n\n  return UserType$1;\n})();\n\n/**\n * Representation of an authenticated user of an app.\n */\nclass User {\n  /**\n   * @param parameters Parameters of the user.\n   */\n  constructor(parameters) {\n    this.app = parameters.app;\n    this.id = parameters.id;\n    this.storage = new UserStorage(this.app.storage, this.id);\n\n    if (\"accessToken\" in parameters && \"refreshToken\" in parameters && \"providerType\" in parameters) {\n      this._accessToken = parameters.accessToken;\n      this._refreshToken = parameters.refreshToken;\n      this.providerType = parameters.providerType; // Save the parameters to storage, for future instances to be hydrated from\n\n      this.storage.accessToken = parameters.accessToken;\n      this.storage.refreshToken = parameters.refreshToken;\n      this.storage.providerType = parameters.providerType;\n    } else {\n      // Hydrate the rest of the parameters from storage\n      this._accessToken = this.storage.accessToken;\n      this._refreshToken = this.storage.refreshToken;\n      const providerType = this.storage.providerType;\n      this._profile = this.storage.profile;\n\n      if (providerType) {\n        this.providerType = providerType;\n      } else {\n        throw new Error(\"Storage is missing a provider type\");\n      }\n    }\n\n    this.fetcher = this.app.fetcher.clone({\n      userContext: {\n        currentUser: this\n      }\n    });\n    this.apiKeys = new ApiKeyAuth(this.fetcher);\n    this.functions = FunctionsFactory.create(this.fetcher);\n  }\n  /**\n   * @returns The access token used to authenticate the user towards MongoDB Realm.\n   */\n\n\n  get accessToken() {\n    return this._accessToken;\n  }\n  /**\n   * @param token The new access token.\n   */\n\n\n  set accessToken(token) {\n    this._accessToken = token;\n    this.storage.accessToken = token;\n  }\n  /**\n   * @returns The refresh token used to issue new access tokens.\n   */\n\n\n  get refreshToken() {\n    return this._refreshToken;\n  }\n  /**\n   * @param token The new refresh token.\n   */\n\n\n  set refreshToken(token) {\n    this._refreshToken = token;\n    this.storage.refreshToken = token;\n  }\n  /**\n   * @returns The current state of the user.\n   */\n\n\n  get state() {\n    if (this.id in this.app.allUsers) {\n      return this.refreshToken === null ? UserState.LoggedOut : UserState.Active;\n    } else {\n      return UserState.Removed;\n    }\n  }\n  /**\n   * @returns The logged in state of the user.\n   */\n\n\n  get isLoggedIn() {\n    return this.state === UserState.Active;\n  }\n\n  get customData() {\n    if (this.accessToken) {\n      const decodedToken = this.decodeAccessToken();\n      return decodedToken.userData;\n    } else {\n      throw new Error(\"Cannot read custom data without an access token\");\n    }\n  }\n  /**\n   * @returns Profile containing detailed information about the user.\n   */\n\n\n  get profile() {\n    if (this._profile) {\n      return this._profile.data;\n    } else {\n      throw new Error(\"A profile was never fetched for this user\");\n    }\n  }\n\n  get identities() {\n    if (this._profile) {\n      return this._profile.identities;\n    } else {\n      throw new Error(\"A profile was never fetched for this user\");\n    }\n  }\n\n  get deviceId() {\n    if (this.accessToken) {\n      const payload = this.accessToken.split(\".\")[1];\n\n      if (payload) {\n        const parsedPayload = JSON.parse(base64.Base64.decode(payload));\n        const deviceId = parsedPayload[\"baas_device_id\"];\n\n        if (typeof deviceId === \"string\" && deviceId !== DEFAULT_DEVICE_ID) {\n          return deviceId;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Refresh the users profile data.\n   */\n\n\n  refreshProfile() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      // Fetch the latest profile\n      const response = yield _this13.fetcher.fetchJSON({\n        method: \"GET\",\n        path: routes.api().auth().profile().path\n      }); // Create a profile instance\n\n      _this13._profile = new UserProfile(response); // Store this for later hydration\n\n      _this13.storage.profile = _this13._profile;\n    })();\n  }\n  /**\n   * Log out the user, invalidating the session (and its refresh token).\n   */\n\n\n  logOut() {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      // Invalidate the refresh token\n      try {\n        if (_this14._refreshToken !== null) {\n          yield _this14.fetcher.fetchJSON({\n            method: \"DELETE\",\n            path: routes.api().auth().session().path,\n            tokenType: \"refresh\"\n          });\n        }\n      } finally {\n        // Forget the access and refresh token\n        _this14.accessToken = null;\n        _this14.refreshToken = null;\n      }\n    })();\n  }\n  /** @inheritdoc */\n\n\n  linkCredentials(credentials) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const response = yield _this15.app.authenticator.authenticate(credentials, _this15); // Sanity check the response\n\n      if (_this15.id !== response.userId) {\n        const details = `got user id ${response.userId} expected ${_this15.id}`;\n        throw new Error(`Link response ment for another user (${details})`);\n      } // Update the access token\n\n\n      _this15.accessToken = response.accessToken; // Refresh the profile to include the new identity\n\n      yield _this15.refreshProfile();\n    })();\n  }\n  /**\n   * Request a new access token, using the refresh token.\n   */\n\n\n  refreshAccessToken() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const response = yield _this16.fetcher.fetchJSON({\n        method: \"POST\",\n        path: routes.api().auth().session().path,\n        tokenType: \"refresh\"\n      });\n      const {\n        access_token: accessToken\n      } = response;\n\n      if (typeof accessToken === \"string\") {\n        _this16.accessToken = accessToken;\n      } else {\n        throw new Error(\"Expected an 'access_token' in the response\");\n      }\n    })();\n  }\n  /** @inheritdoc */\n\n\n  refreshCustomData() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this17.refreshAccessToken();\n      return _this17.customData;\n    })();\n  }\n  /** @inheritdoc */\n\n\n  callFunction(name, ...args) {\n    return this.functions.callFunction(name, ...args);\n  }\n  /**\n   * @returns A plain ol' JavaScript object representation of the user.\n   */\n\n\n  toJSON() {\n    return {\n      id: this.id,\n      accessToken: this.accessToken,\n      refreshToken: this.refreshToken,\n      profile: this._profile,\n      state: this.state,\n      customData: this.customData\n    };\n  }\n  /** @inheritdoc */\n\n\n  push(serviceName = \"\") {\n    throw new Error(\"Not yet implemented\");\n  }\n  /** @inheritdoc */\n\n\n  mongoClient(serviceName) {\n    return createService(this.fetcher, serviceName);\n  }\n\n  decodeAccessToken() {\n    if (this.accessToken) {\n      // Decode and spread the token\n      const parts = this.accessToken.split(\".\");\n\n      if (parts.length !== 3) {\n        throw new Error(\"Expected an access token with three parts\");\n      } // Decode the payload\n\n\n      const encodedPayload = parts[1];\n      const decodedPayload = base64.Base64.decode(encodedPayload);\n      const parsedPayload = JSON.parse(decodedPayload);\n      const {\n        exp: expires,\n        iat: issuedAt,\n        sub: subject,\n        user_data: userData = {}\n      } = parsedPayload; // Validate the types\n\n      if (typeof expires !== \"number\") {\n        throw new Error(\"Failed to decode access token 'exp'\");\n      } else if (typeof issuedAt !== \"number\") {\n        throw new Error(\"Failed to decode access token 'iat'\");\n      }\n\n      return {\n        expires,\n        issuedAt,\n        subject,\n        userData\n      };\n    } else {\n      throw new Error(\"Missing an access token\");\n    }\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n// TODO: Ensure the static interface of the Credentials class implements the static interface of Realm.Credentials\n// See https://stackoverflow.com/a/43484801\n\n/**\n * Instances of this class can be passed to the `app.logIn` method to authenticate an end-user.\n */\n\n\nclass Credentials {\n  /**\n   * Constructs an instance of credentials.\n   *\n   * @param providerName The name of the authentication provider used when authenticating.\n   * @param providerType The type of the authentication provider used when authenticating.\n   * @param payload The data being sent to the service when authenticating.\n   */\n  constructor(providerName, providerType, payload) {\n    this.providerName = providerName;\n    this.providerType = providerType;\n    this.payload = payload;\n  }\n  /**\n   * Creates credentials that logs in using the [Anonymous Provider](https://docs.mongodb.com/realm/authentication/anonymous/).\n   *\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static anonymous() {\n    return new Credentials(\"anon-user\", \"anon-user\", {});\n  }\n  /**\n   * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).\n   *\n   * @deprecated Use `Credentials.apiKey`.\n   *\n   * @param key The secret content of the API key.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static userApiKey(key) {\n    return new Credentials(\"api-key\", \"api-key\", {\n      key\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).\n   *\n   * @deprecated Use `Credentials.apiKey`.\n   *\n   * @param key The secret content of the API key.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static serverApiKey(key) {\n    return new Credentials(\"api-key\", \"api-key\", {\n      key\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).\n   *\n   * @param key The secret content of the API key.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static apiKey(key) {\n    return new Credentials(\"api-key\", \"api-key\", {\n      key\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Email/Password Provider](https://docs.mongodb.com/realm/authentication/email-password/).\n   * Note: This was formerly known as the \"Username/Password\" provider.\n   *\n   * @param email The end-users email address.\n   * @param password The end-users password.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static emailPassword(email, password) {\n    return new Credentials(\"local-userpass\", \"local-userpass\", {\n      username: email,\n      password\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Custom Function Provider](https://docs.mongodb.com/realm/authentication/custom-function/).\n   *\n   * @param payload The custom payload as expected by the server.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static function(payload) {\n    return new Credentials(\"custom-function\", \"custom-function\", payload);\n  }\n  /**\n   * Creates credentials that logs in using the [Custom JWT Provider](https://docs.mongodb.com/realm/authentication/custom-jwt/).\n   *\n   * @param token The JSON Web Token (JWT).\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static jwt(token) {\n    return new Credentials(\"custom-token\", \"custom-token\", {\n      token\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Google Provider](https://docs.mongodb.com/realm/authentication/google/).\n   *\n   * @param payload The URL that users should be redirected to, the auth code or id token from Google.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static google(payload) {\n    return new Credentials(\"oauth2-google\", \"oauth2-google\", Credentials.derivePayload(payload));\n  }\n  /**\n   * @param payload The payload string.\n   * @returns A payload object based on the string.\n   */\n\n\n  static derivePayload(payload) {\n    if (typeof payload === \"string\") {\n      if (payload.includes(\"://\")) {\n        return this.derivePayload({\n          redirectUrl: payload\n        });\n      } else if (payload.startsWith(\"4/\")) {\n        return this.derivePayload({\n          authCode: payload\n        });\n      } else if (payload.startsWith(\"ey\")) {\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        return this.derivePayload({\n          idToken: payload\n        });\n      } else {\n        throw new Error(`Unexpected payload: ${payload}`);\n      }\n    } else if (Object.keys(payload).length === 1) {\n      if (\"authCode\" in payload || \"redirectUrl\" in payload) {\n        return payload;\n      } else if (\"idToken\" in payload) {\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        return {\n          id_token: payload.idToken\n        };\n      } else {\n        throw new Error(\"Unexpected payload: \" + JSON.stringify(payload));\n      }\n    } else {\n      throw new Error(\"Expected only one property in payload, got \" + JSON.stringify(payload));\n    }\n  }\n  /**\n   * Creates credentials that logs in using the [Facebook Provider](https://docs.mongodb.com/realm/authentication/facebook/).\n   *\n   * @param redirectUrlOrAccessToken The URL that users should be redirected to or the auth code returned from Facebook.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static facebook(redirectUrlOrAccessToken) {\n    return new Credentials(\"oauth2-facebook\", \"oauth2-facebook\", redirectUrlOrAccessToken.includes(\"://\") ? {\n      redirectUrl: redirectUrlOrAccessToken\n    } : {\n      accessToken: redirectUrlOrAccessToken\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Apple ID Provider](https://docs.mongodb.com/realm/authentication/apple/).\n   *\n   * @param redirectUrlOrIdToken The URL that users should be redirected to or the id_token returned from Apple.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n\n\n  static apple(redirectUrlOrIdToken) {\n    return new Credentials(\"oauth2-apple\", \"oauth2-apple\", redirectUrlOrIdToken.includes(\"://\") ? {\n      redirectUrl: redirectUrlOrIdToken\n    } : {\n      // eslint-disable-next-line @typescript-eslint/camelcase\n      id_token: redirectUrlOrIdToken\n    });\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n\nconst USER_IDS_STORAGE_KEY = \"userIds\";\nconst DEVICE_ID_STORAGE_KEY = \"deviceId\";\n/**\n * Storage specific to the app.\n */\n\nclass AppStorage extends PrefixedStorage {\n  /**\n   * @param storage The underlying storage to wrap.\n   * @param appId The id of the app.\n   */\n  constructor(storage, appId) {\n    super(storage, `app(${appId})`);\n  }\n  /**\n   * Reads out the list of user ids from storage.\n   *\n   * @returns A list of user ids.\n   */\n\n\n  getUserIds() {\n    const userIdsString = this.get(USER_IDS_STORAGE_KEY);\n    const userIds = userIdsString ? JSON.parse(userIdsString) : [];\n\n    if (Array.isArray(userIds)) {\n      // Remove any duplicates that might have been added\n      // The Set preserves insertion order\n      return [...new Set(userIds)];\n    } else {\n      throw new Error(\"Expected the user ids to be an array\");\n    }\n  }\n  /**\n   * Sets the list of ids in storage.\n   * Optionally merging with existing ids stored in the storage, by prepending these while voiding duplicates.\n   *\n   * @param userIds The list of ids to store.\n   * @param mergeWithExisting Prepend existing ids to avoid data-races with other apps using this storage.\n   */\n\n\n  setUserIds(userIds, mergeWithExisting) {\n    if (mergeWithExisting) {\n      // Add any existing user id to the end of this list, avoiding duplicates\n      const existingIds = this.getUserIds();\n\n      for (const id of existingIds) {\n        if (userIds.indexOf(id) === -1) {\n          userIds.push(id);\n        }\n      }\n    } // Store the list of ids\n\n\n    this.set(USER_IDS_STORAGE_KEY, JSON.stringify(userIds));\n  }\n  /**\n   * Remove an id from the list of ids.\n   *\n   * @param userId The id of a User to be removed.\n   */\n\n\n  removeUserId(userId) {\n    const existingIds = this.getUserIds();\n    const userIds = existingIds.filter(id => id !== userId); // Store the list of ids\n\n    this.setUserIds(userIds, false);\n  }\n  /**\n   * @returns id of this device (if any exists)\n   */\n\n\n  getDeviceId() {\n    return this.get(DEVICE_ID_STORAGE_KEY);\n  }\n  /**\n   * @param deviceId The id of this device, to send on subsequent authentication requests.\n   */\n\n\n  setDeviceId(deviceId) {\n    this.set(DEVICE_ID_STORAGE_KEY, deviceId);\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n\nconst LOWERCASE_LETTERS = \"abcdefghijklmnopqrstuvwxyz\";\nconst CLOSE_CHECK_INTERVAL = 100; // 10 times per second\n\n/* eslint-disable @typescript-eslint/camelcase */\n\nconst REDIRECT_HASH_TO_RESULT = {\n  _stitch_client_app_id: \"appId\",\n  _baas_client_app_id: \"appId\",\n  _stitch_ua: \"userAuth\",\n  _baas_ua: \"userAuth\",\n  _stitch_link: \"link\",\n  _baas_link: \"link\",\n  _stitch_error: \"error\",\n  _baas_error: \"error\",\n  _stitch_state: \"state\",\n  _baas_state: \"state\"\n};\n/* eslint-enable @typescript-eslint/camelcase */\n\n/**\n * A collection of methods helping implement the OAuth2 flow.\n */\n\nclass OAuth2Helper {\n  /**\n   * @param storage The underlying storage to use when storing and retriving secrets.\n   * @param openWindow An optional function called when a browser window needs to open.\n   */\n  constructor(storage, openWindow = getEnvironment().openWindow) {\n    this.storage = storage.prefix(\"oauth2\");\n    this.openWindow = openWindow;\n  }\n  /**\n   * Parses the query string from the final step of the OAuth flow.\n   *\n   * @param queryString The query string passed through in location.hash.\n   * @returns The result of the OAuth flow.\n   */\n\n\n  static parseRedirectLocation(queryString) {\n    const params = decodeQueryString(queryString);\n    const result = {};\n\n    for (const [p, r] of Object.entries(REDIRECT_HASH_TO_RESULT)) {\n      const value = params[p];\n\n      if (value) {\n        result[r] = value;\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Handle the redirect querystring by parsing it and storing it for others to consume.\n   *\n   * @param queryString The query string containing the encoded result from the OAuth provider.\n   * @param storage The underlying storage used to persist the result.\n   */\n\n\n  static handleRedirect(queryString, storage = getEnvironment().defaultStorage) {\n    const result = OAuth2Helper.parseRedirectLocation(queryString);\n    const {\n      state,\n      error\n    } = result;\n\n    if (typeof state === \"string\") {\n      const oauth2Storage = storage.prefix(\"oauth2\");\n      const stateStorage = OAuth2Helper.getStateStorage(oauth2Storage, state);\n      stateStorage.set(\"result\", JSON.stringify(result));\n    } else if (error) {\n      throw new Error(`Failed to handle OAuth 2.0 redirect: ${error}`);\n    } else {\n      throw new Error(\"Failed to handle OAuth 2.0 redirect.\");\n    }\n  }\n  /**\n   * Decodes the authInfo string into its seperate parts.\n   *\n   * @param authInfo An authInfo string returned from the server.\n   * @returns An object containing the separate parts of the authInfo string.\n   */\n\n\n  static decodeAuthInfo(authInfo) {\n    const parts = (authInfo || \"\").split(\"$\");\n\n    if (parts.length === 4) {\n      const [accessToken, refreshToken, userId, deviceId] = parts;\n      return {\n        accessToken,\n        refreshToken,\n        userId,\n        deviceId\n      };\n    } else {\n      throw new Error(\"Failed to decode 'authInfo' into ids and tokens\");\n    }\n  }\n  /**\n   * Get the storage key associated of an secret associated with a state.\n   *\n   * @param storage The root storage used to derive a \"state namespaced\" storage.\n   * @param state The random state.\n   * @returns The storage associated with a particular state.\n   */\n\n\n  static getStateStorage(storage, state) {\n    return storage.prefix(`state(${state})`);\n  }\n  /**\n   * Open a window and wait for the redirect to be handled.\n   *\n   * @param url The URL to open.\n   * @param state The state which will be used to listen for storage updates.\n   * @returns The result passed through the redirect.\n   */\n\n\n  openWindowAndWaitForRedirect(url, state) {\n    const stateStorage = OAuth2Helper.getStateStorage(this.storage, state); // Return a promise that resolves when the  gets known\n\n    return new Promise((resolve, reject) => {\n      let redirectWindow = null; // We're declaring the interval now to enable referencing before its initialized\n\n      let windowClosedInterval; // eslint-disable-line prefer-const\n\n      const handleStorageUpdate = () => {\n        // Trying to get the secret from storage\n        const result = stateStorage.get(\"result\");\n\n        if (result) {\n          const parsedResult = JSON.parse(result); // The secret got updated!\n\n          stateStorage.removeListener(handleStorageUpdate); // Clear the storage to prevent others from reading this\n\n          stateStorage.clear(); // Try closing the newly created window\n\n          try {\n            if (redirectWindow) {\n              // Stop checking if the window closed\n              clearInterval(windowClosedInterval);\n              redirectWindow.close();\n            }\n          } catch (err) {\n            console.warn(`Failed closing redirect window: ${err}`);\n          } finally {\n            resolve(parsedResult);\n          }\n        }\n      }; // Add a listener to the state storage, awaiting an update to the secret\n\n\n      stateStorage.addListener(handleStorageUpdate); // Open up a window\n\n      redirectWindow = this.openWindow(url); // Not using a const, because we need the two listeners to reference each other when removing the other.\n\n      windowClosedInterval = setInterval(() => {\n        // Polling \"closed\" because registering listeners on the window violates cross-origin policies\n        if (!redirectWindow) {\n          // No need to keep polling for a window that we can't check\n          clearInterval(windowClosedInterval);\n        } else if (redirectWindow.closed) {\n          // Stop polling the window state\n          clearInterval(windowClosedInterval); // Stop listening for changes to the storage\n\n          stateStorage.removeListener(handleStorageUpdate); // Reject the promise\n\n          const err = new Error(\"Window closed\");\n          reject(err);\n        }\n      }, CLOSE_CHECK_INTERVAL);\n    });\n  }\n  /**\n   * Generate a random state string.\n   *\n   * @returns The random state string.\n   */\n\n\n  generateState() {\n    return generateRandomString(12, LOWERCASE_LETTERS);\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n\nconst REDIRECT_LOCATION_HEADER = \"x-baas-location\";\n/**\n * Handles authentication and linking of users.\n */\n\nclass Authenticator {\n  /**\n   * @param fetcher The fetcher used to fetch responses from the server.\n   * @param storage The storage used when completing OAuth 2.0 flows (should not be scoped to a specific app).\n   * @param getDeviceInformation Called to get device information to be sent to the server.\n   */\n  constructor(fetcher, storage, getDeviceInformation) {\n    this.fetcher = fetcher;\n    this.oauth2 = new OAuth2Helper(storage);\n    this.getDeviceInformation = getDeviceInformation;\n  }\n  /**\n   * @param credentials Credentials to use when logging in.\n   * @param linkingUser A user requesting to link.\n   */\n\n\n  authenticate(credentials, linkingUser) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const deviceInformation = _this18.getDeviceInformation();\n\n      const isLinking = typeof linkingUser === \"object\";\n\n      if (credentials.providerType.startsWith(\"oauth2\") && typeof credentials.payload.redirectUrl === \"string\") {\n        // Initiate the OAuth2 flow by generating a state and fetch a redirect URL\n        const state = _this18.oauth2.generateState();\n\n        const url = yield _this18.getLogInUrl(credentials, isLinking, {\n          state,\n          redirect: credentials.payload.redirectUrl,\n          // Ensure redirects are communicated in a header different from \"Location\" and status remains 200 OK\n          providerRedirectHeader: isLinking ? true : undefined,\n          // Add the device information, only if we're not linking - since that request won't have a body of its own.\n          device: !isLinking ? deviceInformation.encode() : undefined\n        }); // If we're linking, we need to send the users access token in the request\n\n        if (isLinking) {\n          const response = yield _this18.fetcher.fetch({\n            method: \"GET\",\n            url,\n            tokenType: isLinking ? \"access\" : \"none\",\n            user: linkingUser,\n            // The response will set a cookie that we need to tell the browser to store\n            mode: \"cors\",\n            credentials: \"include\"\n          }); // If a response header contains a redirect URL: Open a window and wait for the redirect to be handled\n\n          const redirectUrl = response.headers.get(REDIRECT_LOCATION_HEADER);\n\n          if (redirectUrl) {\n            return _this18.openWindowAndWaitForAuthResponse(redirectUrl, state);\n          } else {\n            throw new Error(`Missing ${REDIRECT_LOCATION_HEADER} header`);\n          }\n        } else {\n          // Otherwise we can open a window and let the server redirect the user right away\n          // This gives lower latency (as we don't need the client to receive and execute the redirect in code)\n          // This also has less dependency on cookies and doesn't sent any tokens.\n          return _this18.openWindowAndWaitForAuthResponse(url, state);\n        }\n      } else {\n        const logInUrl = yield _this18.getLogInUrl(credentials, isLinking);\n        const response = yield _this18.fetcher.fetchJSON({\n          method: \"POST\",\n          url: logInUrl,\n          body: { ...credentials.payload,\n            options: {\n              device: deviceInformation.toJSON()\n            }\n          },\n          tokenType: isLinking ? \"access\" : \"none\",\n          user: linkingUser\n        }); // Spread out values from the response and ensure they're valid\n\n        const {\n          user_id: userId,\n          access_token: accessToken,\n          refresh_token: refreshToken = null,\n          device_id: deviceId\n        } = response;\n\n        if (typeof userId !== \"string\") {\n          throw new Error(\"Expected a user id in the response\");\n        }\n\n        if (typeof accessToken !== \"string\") {\n          throw new Error(\"Expected an access token in the response\");\n        }\n\n        return {\n          userId,\n          accessToken,\n          refreshToken,\n          deviceId\n        };\n      }\n    })();\n  }\n  /**\n   * @param credentials Credentials to use when logging in.\n   * @param link Should the request link with the current user?\n   * @param extraQueryParams Any extra parameters to include in the query string\n   */\n\n\n  getLogInUrl(credentials, link = false, extraQueryParams = {}) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      // See https://github.com/mongodb/stitch-js-sdk/blob/310f0bd5af80f818cdfbc3caf1ae29ffa8e9c7cf/packages/core/sdk/src/auth/internal/CoreStitchAuth.ts#L746-L780\n      const appRoute = _this19.fetcher.appRoute;\n      const loginRoute = appRoute.authProvider(credentials.providerName).login();\n      const qs = encodeQueryString({\n        link: link ? \"true\" : undefined,\n        ...extraQueryParams\n      });\n      const locationUrl = yield _this19.fetcher.locationUrl;\n      return locationUrl + loginRoute.path + qs;\n    })();\n  }\n\n  openWindowAndWaitForAuthResponse(redirectUrl, state) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      const redirectResult = yield _this20.oauth2.openWindowAndWaitForRedirect(redirectUrl, state); // Decode the auth info (id, tokens, etc.) from the result of the redirect\n\n      return OAuth2Helper.decodeAuthInfo(redirectResult.userAuth);\n    })();\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n// TODO: Determine if the shape of an error response is specific to each service or widely used.\n\n/**\n * An error produced while communicating with the MongoDB Realm server.\n */\n\n\nclass MongoDBRealmError extends Error {\n  constructor(method, url, statusCode, statusText, error, errorCode, link) {\n    const summary = statusText ? `status ${statusCode} ${statusText}` : `status ${statusCode}`;\n\n    if (typeof error === \"string\") {\n      super(`Request failed (${method} ${url}): ${error} (${summary})`);\n    } else {\n      super(`Request failed (${method} ${url}): (${summary})`);\n    }\n\n    this.method = method;\n    this.url = url;\n    this.statusText = statusText;\n    this.statusCode = statusCode;\n    this.error = error;\n    this.errorCode = errorCode;\n    this.link = link;\n  }\n  /**\n   * Constructs and returns an error from a request and a response.\n   * Note: The caller must throw this error themselves.\n   *\n   * @param request The request sent to the server.\n   * @param response A raw response, as returned from the server.\n   */\n\n\n  static fromRequestAndResponse(request, response) {\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        url,\n        method\n      } = request;\n      const {\n        status,\n        statusText\n      } = response;\n\n      if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.startsWith(\"application/json\")) {\n        const body = yield response.json();\n        const error = body.error || \"No message\";\n        const errorCode = body.error_code;\n        const link = body.link;\n        return new MongoDBRealmError(method, url, status, statusText, error, errorCode, link);\n      } else {\n        return new MongoDBRealmError(method, url, status, statusText);\n      }\n    })();\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * @param body A possible resonse body.\n * @returns An async iterator.\n */\n\n\nfunction asyncIteratorFromResponseBody(body) {\n  if (typeof body !== \"object\" || body === null) {\n    throw new Error(\"Expected a non-null object\");\n  } else if (Symbol.asyncIterator in body) {\n    return body;\n  } else if (\"getReader\" in body) {\n    const stream = body;\n    return {\n      [Symbol.asyncIterator]() {\n        const reader = stream.getReader();\n        return {\n          next() {\n            return reader.read();\n          },\n\n          return() {\n            return _asyncToGenerator(function* () {\n              yield reader.cancel();\n              return {\n                done: true,\n                value: null\n              };\n            })();\n          }\n\n        };\n      }\n\n    };\n  } else {\n    throw new Error(\"Expected an AsyncIterable or a ReadableStream\");\n  }\n}\n/**\n * Wraps a NetworkTransport from the \"realm-network-transport\" package.\n * Extracts error messages and throws `MongoDBRealmError` objects upon failures.\n * Injects access or refresh tokens for a current or specific user.\n * Refreshes access tokens if requests fails due to a 401 error.\n * Optionally parses response as JSON before returning it.\n * Fetches and exposes an app's location url.\n */\n\n\nclass Fetcher {\n  /**\n   * @param config A configuration of the fetcher.\n   */\n  constructor({\n    appId,\n    transport,\n    userContext,\n    locationUrlContext\n  }) {\n    this.appId = appId;\n    this.transport = transport;\n    this.userContext = userContext;\n    this.locationUrlContext = locationUrlContext;\n  }\n  /**\n   * @param user An optional user to generate the header for.\n   * @param tokenType The type of token (access or refresh).\n   * @returns An object containing the user's token as \"Authorization\" header or undefined if no user is given.\n   */\n\n\n  static buildAuthorizationHeader(user, tokenType) {\n    if (!user || tokenType === \"none\") {\n      return {};\n    } else if (tokenType === \"access\") {\n      return {\n        Authorization: `Bearer ${user.accessToken}`\n      };\n    } else if (tokenType === \"refresh\") {\n      return {\n        Authorization: `Bearer ${user.refreshToken}`\n      };\n    } else {\n      throw new Error(`Unexpected token type (${tokenType})`);\n    }\n  }\n  /**\n   * @param body The body string or object passed from a request.\n   * @returns An object optionally specifying the \"Content-Type\" header.\n   */\n\n\n  static buildBody(body) {\n    if (!body) {\n      return;\n    } else if (typeof body === \"object\" && body !== null) {\n      return JSON.stringify(serialize(body));\n    } else if (typeof body === \"string\") {\n      return body;\n    } else {\n      console.log(\"body is\", body);\n      throw new Error(\"Unexpected type of body\");\n    }\n  }\n  /**\n   * @param body The body string or object passed from a request.\n   * @returns An object optionally specifying the \"Content-Type\" header.\n   */\n\n\n  static buildJsonHeader(body) {\n    if (body && body.length > 0) {\n      return {\n        \"Content-Type\": \"application/json\"\n      };\n    } else {\n      return {};\n    }\n  }\n\n  clone(config) {\n    return new Fetcher({\n      appId: this.appId,\n      transport: this.transport,\n      userContext: this.userContext,\n      locationUrlContext: this.locationUrlContext,\n      ...config\n    });\n  }\n  /**\n   * Fetch a network resource as an authenticated user.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns The response from the server.\n   */\n\n\n  fetch(request) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        path,\n        url,\n        tokenType = \"access\",\n        user = _this21.userContext.currentUser,\n        ...restOfRequest\n      } = request;\n\n      if (typeof path === \"string\" && typeof url === \"string\") {\n        throw new Error(\"Use of 'url' and 'path' mutually exclusive\");\n      } else if (typeof path === \"string\") {\n        // Derive the URL\n        const url = (yield _this21.locationUrlContext.locationUrl) + path;\n        return _this21.fetch({ ...request,\n          path: undefined,\n          url\n        });\n      } else if (typeof url === \"string\") {\n        const response = yield _this21.transport.fetch({ ...restOfRequest,\n          url,\n          headers: { ...Fetcher.buildAuthorizationHeader(user, tokenType),\n            ...request.headers\n          }\n        });\n\n        if (response.ok) {\n          return response;\n        } else if (user && response.status === 401 && tokenType === \"access\") {\n          // If the access token has expired, it would help refreshing it\n          yield user.refreshAccessToken(); // Retry with the specific user, since the currentUser might have changed.\n\n          return _this21.fetch({ ...request,\n            user\n          });\n        } else {\n          if (user && response.status === 401 && tokenType === \"refresh\") {\n            // A 401 error while using the refresh token indicates the token has an issue.\n            // Reset the tokens to prevent a lock.\n            user.accessToken = null;\n            user.refreshToken = null;\n          } // Throw an error with a message extracted from the body\n\n\n          throw yield MongoDBRealmError.fromRequestAndResponse(request, response);\n        }\n      } else {\n        throw new Error(\"Expected either 'url' or 'path'\");\n      }\n    })();\n  }\n  /**\n   * Fetch a network resource as an authenticated user and parse the result as extended JSON.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns The response from the server, parsed as extended JSON.\n   */\n\n\n  fetchJSON(request) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        body\n      } = request;\n      const serializedBody = Fetcher.buildBody(body);\n      const contentTypeHeaders = Fetcher.buildJsonHeader(serializedBody);\n      const response = yield _this22.fetch({ ...request,\n        body: serializedBody,\n        headers: {\n          Accept: \"application/json\",\n          ...contentTypeHeaders,\n          ...request.headers\n        }\n      });\n      const contentType = response.headers.get(\"content-type\");\n\n      if (contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(\"application/json\")) {\n        const responseBody = yield response.json();\n        return deserialize(responseBody);\n      } else if (contentType === null) {\n        return null;\n      } else {\n        throw new Error(`Expected JSON response, got \"${contentType}\"`);\n      }\n    })();\n  }\n  /**\n   * Fetch an \"event-stream\" resource as an authenticated user.\n   *\n   * @param request The request which should be sent to the server.\n   */\n\n\n  fetchStream(request) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        body\n      } = yield _this23.fetch({ ...request,\n        headers: {\n          Accept: \"text/event-stream\",\n          ...request.headers\n        }\n      });\n      return asyncIteratorFromResponseBody(body);\n    })();\n  }\n  /**\n   * @returns The path of the app route.\n   */\n\n\n  get appRoute() {\n    return routes.api().app(this.appId);\n  }\n  /**\n   * @returns A promise of the location URL of the app.\n   */\n\n\n  get locationUrl() {\n    return this.locationUrlContext.locationUrl;\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * The key in a storage on which the device id is stored.\n */\n\n\nconst DEVICE_ID_STORAGE_KEY$1 = \"deviceId\";\nvar DeviceFields = /*#__PURE__*/(() => {\n  (function (DeviceFields) {\n    DeviceFields[\"DEVICE_ID\"] = \"deviceId\";\n    DeviceFields[\"APP_ID\"] = \"appId\";\n    DeviceFields[\"APP_VERSION\"] = \"appVersion\";\n    DeviceFields[\"PLATFORM\"] = \"platform\";\n    DeviceFields[\"PLATFORM_VERSION\"] = \"platformVersion\";\n    DeviceFields[\"SDK_VERSION\"] = \"sdkVersion\";\n  })(DeviceFields || (DeviceFields = {}));\n\n  return DeviceFields;\n})();\n\n/**\n * Information describing the device, app and SDK.\n */\nclass DeviceInformation {\n  /**\n   * @param params Construct the device information from these parameters.\n   */\n  constructor({\n    appId,\n    appVersion,\n    deviceId\n  }) {\n    /**\n     * The version of the Realm Web SDK (constant provided by Rollup).\n     */\n    this.sdkVersion = \"1.3.0\";\n    const environment = getEnvironment();\n    this.platform = environment.platform;\n    this.platformVersion = environment.platformVersion;\n    this.appId = appId;\n    this.appVersion = appVersion;\n    this.deviceId = deviceId;\n  }\n  /**\n   * @returns An base64 URI encoded representation of the device information.\n   */\n\n\n  encode() {\n    const obj = removeKeysWithUndefinedValues(this);\n    return base64.Base64.encode(JSON.stringify(obj));\n  }\n  /**\n   * @returns The defaults\n   */\n\n\n  toJSON() {\n    return removeKeysWithUndefinedValues(this);\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * Default base url to prefix all requests if no baseUrl is specified in the configuration.\n */\n\n\nconst DEFAULT_BASE_URL = \"https://stitch.mongodb.com\";\n/**\n * MongoDB Realm App\n */\n\nlet App = /*#__PURE__*/(() => {\n  class App {\n    /**\n     * Construct a Realm App, either from the Realm App id visible from the MongoDB Realm UI or a configuration.\n     *\n     * @param idOrConfiguration The Realm App id or a configuration to use for this app.\n     */\n    constructor(idOrConfiguration) {\n      /**\n       * An array of active and logged-out users.\n       * Elements in the beginning of the array is considered more recent than the later elements.\n       */\n      this.users = [];\n      /**\n       * A promise resolving to the App's location url.\n       */\n\n      this._locationUrl = null; // If the argument is a string, convert it to a simple configuration object.\n\n      const configuration = typeof idOrConfiguration === \"string\" ? {\n        id: idOrConfiguration\n      } : idOrConfiguration; // Initialize properties from the configuration\n\n      if (typeof configuration === \"object\" && typeof configuration.id === \"string\") {\n        this.id = configuration.id;\n      } else {\n        throw new Error(\"Missing a MongoDB Realm app-id\");\n      }\n\n      this.baseUrl = configuration.baseUrl || DEFAULT_BASE_URL;\n\n      if (configuration.skipLocationRequest) {\n        // Use the base url directly, instead of requesting a location URL from the server\n        this._locationUrl = Promise.resolve(this.baseUrl);\n      }\n\n      this.localApp = configuration.app;\n      const {\n        storage,\n        transport = new DefaultNetworkTransport()\n      } = configuration; // Construct a fetcher wrapping the network transport\n\n      this.fetcher = new Fetcher({\n        appId: this.id,\n        userContext: this,\n        locationUrlContext: this,\n        transport\n      }); // Construct the auth providers\n\n      this.emailPasswordAuth = new EmailPasswordAuth(this.fetcher); // Construct the storage\n\n      const baseStorage = storage || getEnvironment().defaultStorage;\n      this.storage = new AppStorage(baseStorage, this.id);\n      this.authenticator = new Authenticator(this.fetcher, baseStorage, () => this.deviceInformation); // Hydrate the app state from storage\n\n      try {\n        this.hydrate();\n      } catch (err) {\n        // The storage was corrupted\n        this.storage.clear(); // A failed hydration shouldn't throw and break the app experience\n        // Since this is \"just\" persisted state that unfortunately got corrupted or partially lost\n\n        console.warn(\"Realm app hydration failed:\", err.message);\n      }\n    }\n    /**\n     * Get or create a singleton Realm App from an id.\n     * Calling this function multiple times with the same id will return the same instance.\n     *\n     * @param id The Realm App id visible from the MongoDB Realm UI or a configuration.\n     * @returns The Realm App instance.\n     */\n\n\n    static getApp(id) {\n      if (id in App.appCache) {\n        return App.appCache[id];\n      } else {\n        const instance = new App(id);\n        App.appCache[id] = instance;\n        return instance;\n      }\n    }\n    /**\n     * Switch user.\n     *\n     * @param nextUser The user or id of the user to switch to.\n     */\n\n\n    switchUser(nextUser) {\n      const index = this.users.findIndex(u => u === nextUser);\n\n      if (index === -1) {\n        throw new Error(\"The user was never logged into this app\");\n      } // Remove the user from the stack\n\n\n      const [user] = this.users.splice(index, 1); // Insert the user in the beginning of the stack\n\n      this.users.unshift(user);\n    }\n    /**\n     * Log in a user.\n     *\n     * @param credentials Credentials to use when logging in.\n     * @param fetchProfile Should the users profile be fetched? (default: true)\n     */\n\n\n    logIn(credentials, fetchProfile = true) {\n      var _this24 = this;\n\n      return _asyncToGenerator(function* () {\n        const response = yield _this24.authenticator.authenticate(credentials);\n\n        const user = _this24.createOrUpdateUser(response, credentials.providerType); // Let's ensure this will be the current user, in case the user object was reused.\n\n\n        _this24.switchUser(user); // If neeeded, fetch and set the profile on the user\n\n\n        if (fetchProfile) {\n          yield user.refreshProfile();\n        } // Persist the user id in the storage,\n        // merging to avoid overriding logins from other apps using the same underlying storage\n\n\n        _this24.storage.setUserIds(_this24.users.map(u => u.id), true); // Read out and store the device id from the server\n\n\n        const deviceId = response.deviceId;\n\n        if (deviceId && deviceId !== \"000000000000000000000000\") {\n          _this24.storage.set(DEVICE_ID_STORAGE_KEY$1, deviceId);\n        } // Return the user\n\n\n        return user;\n      })();\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    removeUser(user) {\n      var _this25 = this;\n\n      return _asyncToGenerator(function* () {\n        // Remove the user from the list of users\n        const index = _this25.users.findIndex(u => u === user);\n\n        if (index === -1) {\n          throw new Error(\"The user was never logged into this app\");\n        }\n\n        _this25.users.splice(index, 1); // Log out the user - this removes access and refresh tokens from storage\n\n\n        yield user.logOut(); // Remove the users profile from storage\n\n        _this25.storage.remove(`user(${user.id}):profile`); // Remove the user from the storage\n\n\n        _this25.storage.removeUserId(user.id);\n      })();\n    }\n    /**\n     * The currently active user (or null if no active users exists).\n     *\n     * @returns the currently active user or null.\n     */\n\n\n    get currentUser() {\n      const activeUsers = this.users.filter(user => user.state === UserState.Active);\n\n      if (activeUsers.length === 0) {\n        return null;\n      } else {\n        // Current user is the top of the stack\n        return activeUsers[0];\n      }\n    }\n    /**\n     * All active and logged-out users:\n     *  - First in the list are active users (ordered by most recent call to switchUser or login)\n     *  - Followed by logged out users (also ordered by most recent call to switchUser or login).\n     *\n     * @returns An array of users active or loggedout users (current user being the first).\n     */\n\n\n    get allUsers() {\n      // Returning a freezed copy of the list of users to prevent outside changes\n      return Object.fromEntries(this.users.map(user => [user.id, user]));\n    }\n    /**\n     * @returns A promise of the app URL, with the app location resolved.\n     */\n\n\n    get locationUrl() {\n      if (!this._locationUrl) {\n        const path = routes.api().app(this.id).location().path;\n        this._locationUrl = this.fetcher.fetchJSON({\n          method: \"GET\",\n          url: this.baseUrl + path,\n          tokenType: \"none\"\n        }).then(({\n          hostname\n        }) => {\n          if (typeof hostname !== \"string\") {\n            throw new Error(\"Expected response to contain a 'hostname'\");\n          } else {\n            return hostname;\n          }\n        }).catch(err => {\n          // Reset the location to allow another request to fetch again.\n          this._locationUrl = null;\n          throw err;\n        });\n      }\n\n      return this._locationUrl;\n    }\n    /**\n     * @returns Information about the current device, sent to the server when authenticating.\n     */\n\n\n    get deviceInformation() {\n      const deviceIdStr = this.storage.getDeviceId();\n      const deviceId = typeof deviceIdStr === \"string\" && deviceIdStr !== \"000000000000000000000000\" ? new ObjectId(deviceIdStr) : undefined;\n      return new DeviceInformation({\n        appId: this.localApp ? this.localApp.name : undefined,\n        appVersion: this.localApp ? this.localApp.version : undefined,\n        deviceId\n      });\n    }\n    /**\n     * Create (and store) a new user or update an existing user's access and refresh tokens.\n     * This helps de-duplicating users in the list of users known to the app.\n     *\n     * @param response A response from the Authenticator.\n     * @param providerType The type of the authentication provider used.\n     * @returns A new or an existing user.\n     */\n\n\n    createOrUpdateUser(response, providerType) {\n      const existingUser = this.users.find(u => u.id === response.userId);\n\n      if (existingUser) {\n        // Update the users access and refresh tokens\n        existingUser.accessToken = response.accessToken;\n        existingUser.refreshToken = response.refreshToken;\n        return existingUser;\n      } else {\n        // Create and store a new user\n        if (!response.refreshToken) {\n          throw new Error(\"No refresh token in response from server\");\n        }\n\n        const user = new User({\n          app: this,\n          id: response.userId,\n          accessToken: response.accessToken,\n          refreshToken: response.refreshToken,\n          providerType\n        });\n        this.users.unshift(user);\n        return user;\n      }\n    }\n    /**\n     * Restores the state of the app (active and logged-out users) from the storage\n     */\n\n\n    hydrate() {\n      const userIds = this.storage.getUserIds();\n      this.users = userIds.map(id => new User({\n        app: this,\n        id\n      }));\n    }\n\n  }\n\n  /**\n   * A map of app instances returned from calling getApp.\n   */\n  App.appCache = {};\n  /**\n   * Instances of this class can be passed to the `app.logIn` method to authenticate an end-user.\n   */\n\n  App.Credentials = Credentials; ////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Get or create a singleton Realm App from an id.\n   * Calling this function multiple times with the same id will return the same instance.\n   *\n   * @param id The Realm App id visible from the MongoDB Realm UI or a configuration.\n   * @returns The Realm App instance.\n   */\n\n  return App;\n})();\n\nfunction getApp(id) {\n  return App.getApp(id);\n} ////////////////////////////////////////////////////////////////////////////\n\n/**\n * In-memory storage that will not be persisted.\n */\n\n\nclass LocalStorage {\n  /**\n   * Constructs a LocalStorage using the global window.\n   */\n  constructor() {\n    if (typeof window === \"object\") {\n      this.window = window;\n    } else {\n      throw new Error(\"Cannot use LocalStorage without a global window object\");\n    }\n  }\n  /** @inheritdoc */\n\n\n  get(key) {\n    return this.window.localStorage.getItem(key);\n  }\n  /** @inheritdoc */\n\n\n  set(key, value) {\n    return this.window.localStorage.setItem(key, value);\n  }\n  /** @inheritdoc */\n\n\n  remove(key) {\n    return this.window.localStorage.removeItem(key);\n  }\n  /** @inheritdoc */\n\n\n  prefix(keyPart) {\n    return new PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n\n\n  clear(prefix) {\n    const keys = []; // Iterate all keys to find the once have a matching prefix.\n\n    for (let i = 0; i < this.window.localStorage.length; i++) {\n      const key = this.window.localStorage.key(i);\n\n      if (key && (!prefix || key.startsWith(prefix))) {\n        keys.push(key);\n      }\n    } // Remove the items in a seperate loop to avoid updating while iterating.\n\n\n    for (const key of keys) {\n      this.window.localStorage.removeItem(key);\n    }\n  }\n  /** @inheritdoc */\n\n\n  addListener(listener) {\n    return this.window.addEventListener(\"storage\", listener);\n  }\n  /** @inheritdoc */\n\n\n  removeListener(listener) {\n    return this.window.removeEventListener(\"storage\", listener);\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n\nconst browser = detect();\nconst environment$1 = {\n  defaultStorage: new LocalStorage().prefix(\"realm-web\"),\n  openWindow: url => window.open(url),\n  platform: (browser === null || browser === void 0 ? void 0 : browser.name) || \"web\",\n  platformVersion: (browser === null || browser === void 0 ? void 0 : browser.version) || \"0.0.0\",\n  TextDecoder\n};\nsetEnvironment(environment$1);\n/**\n * Handle an OAuth 2.0 redirect.\n *\n * @param location An optional location to use (defaults to the windows current location).\n * @param storage Optional storage used to save any results from the location.\n */\n\nfunction handleAuthRedirect(location = window.location, storage = environment$1.defaultStorage) {\n  try {\n    const queryString = location.hash.substr(1); // Strip the initial # from the hash\n\n    OAuth2Helper.handleRedirect(queryString, storage);\n  } catch (err) {\n    // Ensure calling this never throws: It should not interrupt a users flow.\n    console.warn(err);\n  }\n}\n\nexport { App, Credentials, DEFAULT_BASE_URL, LocalStorage, MongoDBRealmError, User, UserState, UserType$1 as UserType, getApp, getEnvironment, handleAuthRedirect, setEnvironment };","map":null,"metadata":{},"sourceType":"module"}