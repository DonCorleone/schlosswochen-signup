{"ast":null,"code":"import { of, throwError } from 'rxjs';\nimport { catchError, tap, map } from 'rxjs/operators';\nimport { gql } from 'apollo-angular';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"apollo-angular\";\nexport let ParticipantService = /*#__PURE__*/(() => {\n  class ParticipantService {\n    constructor(http, apolloProvider) {\n      this.http = http;\n      this.apolloProvider = apolloProvider;\n      this.participantsUrl = 'api/participants';\n      this.participants = [];\n      this.apollo = this.apolloProvider.use('writeClient');\n    }\n\n    getParticipants() {\n      if (this.participants) {\n        return of(this.participants);\n      }\n\n      return this.http.get(this.participantsUrl).pipe(tap(data => console.log(JSON.stringify(data))), tap(data => this.participants = data), catchError(this.handleError));\n    }\n\n    updateExternalUserId(ids, variable) {\n      return this.apollo.mutate({\n        mutation: gql`\n          mutation ($ids: [String], $externalUserId: String!) {\n            updateManyParticipants(\n              query: { participant_id_in: $ids }\n              set: { externalUserId: $externalUserId }\n            ) {\n              matchedCount\n            }\n          }\n        `,\n        variables: {\n          ids: ids,\n          externalUserId: variable\n        }\n      }).pipe(tap(result => console.log('ParticipantService.updateExternalUserId: updateManySubscriptionsData', JSON.stringify(result))), map(result => {\n        var _a, _b;\n\n        return (_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.updateManyParticipants) === null || _b === void 0 ? void 0 : _b.matchedCount;\n      }), catchError(this.handleError));\n    }\n\n    upsertParticipant(data, participantId) {\n      return this.apollo.mutate({\n        mutation: gql`\n          mutation ($participant_id: String!, $participantInsertInput: ParticipantInsertInput!) {\n            upsertOneParticipant(\n            query: {participant_id: $participant_id}\n            data: $participantInsertInput)\n            {\n              _id\n              participant_id\n            }\n          }\n        `,\n        variables: {\n          participant_id: participantId,\n          participantInsertInput: data\n        }\n      }).pipe(tap(data => console.log('ParticipantService.createParticipant.insertOneParticipant', JSON.stringify(data))), map(result => {\n        var _a;\n\n        return (_a = result.data) === null || _a === void 0 ? void 0 : _a.data;\n      }), catchError(this.handleError));\n    }\n    /*  deleteParticipant(id: string): Observable<{}> {\n        const headers = new HttpHeaders({ 'Content-Type': 'application/json' });\n        const url = `${this.participantsUrl}/${id}`;\n        return this.http.delete<Participant>(url, { headers }).pipe(\n          tap((data) => console.log('deleteParticipant: ' + id)),\n          tap((data) => {\n            const foundIndex = this.participants.findIndex(\n              (item) => item._id === id\n            );\n            if (foundIndex > -1) {\n              this.participants.splice(foundIndex, 1);\n            }\n          }),\n          catchError(this.handleError)\n        );\n      }*/\n\n    /*  updateParticipant(participant: Participant): Observable<Participant> {\n        const headers = new HttpHeaders({ 'Content-Type': 'application/json' });\n        const url = `${this.participantsUrl}/${participant._id}`;\n        return this.http.put<Participant>(url, participant, { headers }).pipe(\n          tap(() => console.log('updateParticipant: ' + participant._id)),\n          // Update the item in the list\n          // This is required because the selected participant that was edited\n          // was a copy of the item from the array.\n          tap(() => {\n            const foundIndex = this.participants.findIndex(\n              (item) => item._id === participant._id\n            );\n            if (foundIndex > -1) {\n              this.participants[foundIndex] = participant;\n            }\n          }),\n          // Return the participant on an update\n          map(() => participant),\n          catchError(this.handleError)\n        );\n      }*/\n\n\n    handleError(err) {\n      // in a real world app, we may send the server to some remote logging infrastructure\n      // instead of just logging it to the console\n      let errorMessage;\n\n      if (err.error instanceof ErrorEvent) {\n        // A client-side or network error occurred. Handle it accordingly.\n        errorMessage = `An error occurred: ${err.error.message}`;\n      } else {\n        // The backend returned an unsuccessful response code.\n        // The response body may contain clues as to what went wrong,\n        errorMessage = `Backend returned code ${err.status}: ${err.body.error}`;\n      }\n\n      console.error(err);\n      return throwError(errorMessage);\n    }\n\n  }\n\n  ParticipantService.ɵfac = function ParticipantService_Factory(t) {\n    return new (t || ParticipantService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Apollo));\n  };\n\n  ParticipantService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ParticipantService,\n    factory: ParticipantService.ɵfac,\n    providedIn: 'root'\n  });\n  return ParticipantService;\n})();","map":null,"metadata":{},"sourceType":"module"}