{"ast":null,"code":"import { DOCUMENT, CommonModule } from '@angular/common';\nimport { Injectable, InjectionToken, NgModule, ANALYZE_FOR_ENTRY_COMPONENTS, Inject, Optional, Component, Input, ChangeDetectionStrategy, EventEmitter, Output, Attribute, ViewChild, ElementRef, NgZone, ViewContainerRef, ComponentFactoryResolver, Renderer2, Injector, ChangeDetectorRef, Directive, defineInjectable, inject, INJECTOR } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { __rest } from 'tslib';\nimport { debounceTime, switchMap, distinctUntilChanged, take, startWith, map } from 'rxjs/operators';\nimport { AbstractControl, FormArray, FormGroup, FormControl, FormGroupDirective, Validators } from '@angular/forms';\nimport { isObservable, Subject, of, Observable } from 'rxjs';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} formId\n * @param {?} field\n * @param {?} index\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@angular/platform-browser';\nconst _c0 = [\"content\"];\n\nfunction FormlyForm_formly_field_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"formly-field\", 2);\n  }\n\n  if (rf & 2) {\n    const field_r2 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"form\", field_r2.form)(\"options\", field_r2.options)(\"model\", field_r2.model)(\"field\", field_r2);\n  }\n}\n\nconst _c1 = [\"*\"];\nconst _c2 = [\"container\"];\n\nfunction FormlyField_ng_template_0_Template(rf, ctx) {}\n\nconst _c3 = [\"fieldComponent\"];\n\nfunction FormlyGroup_formly_field_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"formly-field\", 1);\n  }\n\n  if (rf & 2) {\n    const f_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"field\", f_r1);\n  }\n}\n\nfunction getFieldId(formId, field, index) {\n  if (field.id) return field.id;\n  /** @type {?} */\n\n  let type = field.type;\n  if (!type && field.template) type = 'template';\n  return [formId, type, field.key, index].join('_');\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction getKeyPath(field) {\n  if (!field.key) {\n    return [];\n  }\n  /* We store the keyPath in the field for performance reasons. This function will be called frequently. */\n\n\n  if (!field._keyPath || field._keyPath.key !== field.key) {\n    /** @type {?} */\n    let path = [];\n\n    if (typeof field.key === 'string') {\n      /** @type {?} */\n      const key = field.key.indexOf('[') === -1 ? field.key : field.key.replace(/\\[(\\w+)\\]/g, '.$1');\n      path = key.indexOf('.') !== -1 ? key.split('.') : [key];\n    } else if (Array.isArray(field.key)) {\n      path = field.key.slice(0);\n    } else {\n      path = [`${field.key}`];\n    }\n\n    field._keyPath = {\n      key: field.key,\n      path\n    };\n  }\n\n  return field._keyPath.path.slice(0);\n}\n/** @type {?} */\n\n\nconst FORMLY_VALIDATORS = ['required', 'pattern', 'minLength', 'maxLength', 'min', 'max'];\n/**\n * @param {?} field\n * @param {?} value\n * @return {?}\n */\n\nfunction assignFieldValue(field, value) {\n  /** @type {?} */\n  let paths = getKeyPath(field);\n\n  if (paths.length === 0) {\n    return;\n  }\n  /** @type {?} */\n\n\n  let root = field;\n\n  while (root.parent) {\n    root = root.parent;\n    paths = [...getKeyPath(root), ...paths];\n  }\n\n  if (value === undefined && field.resetOnHide) {\n    /** @type {?} */\n    const k = paths.pop();\n    /** @type {?} */\n\n    const m = paths.reduce(\n    /**\n    * @param {?} model\n    * @param {?} path\n    * @return {?}\n    */\n    (model, path) => model[path] || {}, root.model);\n    delete m[k];\n    return;\n  }\n\n  assignModelValue(root.model, paths, value);\n}\n/**\n * @param {?} model\n * @param {?} paths\n * @param {?} value\n * @return {?}\n */\n\n\nfunction assignModelValue(model, paths, value) {\n  for (let i = 0; i < paths.length - 1; i++) {\n    /** @type {?} */\n    const path = paths[i];\n\n    if (!model[path] || !isObject(model[path])) {\n      model[path] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n    }\n\n    model = model[path];\n  }\n\n  model[paths[paths.length - 1]] = clone(value);\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction getFieldInitialValue(field) {\n  /** @type {?} */\n  let value = field.options['_initialModel'];\n  /** @type {?} */\n\n  let paths = getKeyPath(field);\n\n  while (field.parent) {\n    field = field.parent;\n    paths = [...getKeyPath(field), ...paths];\n  }\n\n  for (const path of paths) {\n    if (!value) {\n      return undefined;\n    }\n\n    value = value[path];\n  }\n\n  return value;\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction getFieldValue(field) {\n  /** @type {?} */\n  let model = field.parent.model;\n\n  for (const path of getKeyPath(field)) {\n    if (!model) {\n      return model;\n    }\n\n    model = model[path];\n  }\n\n  return model;\n}\n/**\n * @param {?} dest\n * @param {...?} args\n * @return {?}\n */\n\n\nfunction reverseDeepMerge(dest, ...args) {\n  args.forEach(\n  /**\n  * @param {?} src\n  * @return {?}\n  */\n  src => {\n    for (let srcArg in src) {\n      if (isNullOrUndefined(dest[srcArg]) || isBlankString(dest[srcArg])) {\n        dest[srcArg] = clone(src[srcArg]);\n      } else if (objAndSameType(dest[srcArg], src[srcArg])) {\n        reverseDeepMerge(dest[srcArg], src[srcArg]);\n      }\n    }\n  });\n  return dest;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isNullOrUndefined(value) {\n  return value === undefined || value === null;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isBlankString(value) {\n  return value === '';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @param {?} obj1\n * @param {?} obj2\n * @return {?}\n */\n\n\nfunction objAndSameType(obj1, obj2) {\n  return isObject(obj1) && isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2) && !(Array.isArray(obj1) || Array.isArray(obj2));\n}\n/**\n * @param {?} x\n * @return {?}\n */\n\n\nfunction isObject(x) {\n  return x != null && typeof x === 'object';\n}\n/**\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction isPromise(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction clone(value) {\n  if (!isObject(value) || isObservable(value) ||\n  /* instanceof SafeHtmlImpl */\n  value.changingThisBreaksApplicationSecurity || ['RegExp', 'FileList', 'File', 'Blob'].indexOf(value.constructor.name) !== -1) {\n    return value;\n  }\n\n  if (value instanceof Set) {\n    return new Set(value);\n  }\n\n  if (value instanceof Map) {\n    return new Map(value);\n  } // https://github.com/moment/moment/blob/master/moment.js#L252\n\n\n  if (value._isAMomentObject && isFunction(value.clone)) {\n    return value.clone();\n  }\n\n  if (value instanceof AbstractControl) {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice(0).map(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    v => clone(v));\n  } // best way to clone a js object maybe\n  // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n\n  /** @type {?} */\n\n\n  const proto = Object.getPrototypeOf(value);\n  /** @type {?} */\n\n  let c = Object.create(proto);\n  c = Object.setPrototypeOf(c, proto); // need to make a deep copy so we dont use Object.assign\n  // also Object.assign wont copy property descriptor exactly\n\n  return Object.keys(value).reduce(\n  /**\n  * @param {?} newVal\n  * @param {?} prop\n  * @return {?}\n  */\n  (newVal, prop) => {\n    /** @type {?} */\n    const propDesc = Object.getOwnPropertyDescriptor(value, prop);\n\n    if (propDesc.get) {\n      Object.defineProperty(newVal, prop, propDesc);\n    } else {\n      newVal[prop] = clone(value[prop]);\n    }\n\n    return newVal;\n  }, c);\n}\n/**\n * @param {?} field\n * @param {?} prop\n * @param {?} defaultValue\n * @return {?}\n */\n\n\nfunction defineHiddenProp(field, prop, defaultValue) {\n  Object.defineProperty(field, prop, {\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n  field[prop] = defaultValue;\n}\n/**\n * @template T\n * @param {?} o\n * @param {?} prop\n * @param {?} setFn\n * @return {?}\n */\n\n\nfunction wrapProperty(o, prop, setFn) {\n  if (!o._observers) {\n    defineHiddenProp(o, '_observers', {});\n  }\n\n  if (!o._observers[prop]) {\n    o._observers[prop] = [];\n  }\n  /** @type {?} */\n\n\n  let fns = o._observers[prop];\n\n  if (fns.indexOf(setFn) === -1) {\n    fns.push(setFn);\n    setFn({\n      currentValue: o[prop],\n      firstChange: true\n    });\n\n    if (fns.length === 1) {\n      defineHiddenProp(o, `___$${prop}`, o[prop]);\n      Object.defineProperty(o, prop, {\n        configurable: true,\n        get:\n        /**\n        * @return {?}\n        */\n        () => o[`___$${prop}`],\n        set:\n        /**\n        * @param {?} currentValue\n        * @return {?}\n        */\n        currentValue => {\n          if (currentValue !== o[`___$${prop}`]) {\n            /** @type {?} */\n            const previousValue = o[`___$${prop}`];\n            o[`___$${prop}`] = currentValue;\n            fns.forEach(\n            /**\n            * @param {?} changeFn\n            * @return {?}\n            */\n            changeFn => changeFn({\n              previousValue,\n              currentValue,\n              firstChange: false\n            }));\n          }\n        }\n      });\n    }\n  }\n\n  return (\n    /**\n    * @return {?}\n    */\n    () => fns.splice(fns.indexOf(setFn), 1)\n  );\n}\n/**\n * @param {?} form\n * @param {?} action\n * @return {?}\n */\n\n\nfunction reduceFormUpdateValidityCalls(form, action) {\n  /** @type {?} */\n  const updateValidity = form._updateTreeValidity.bind(form);\n  /** @type {?} */\n\n\n  let updateValidityArgs = {\n    called: false,\n    emitEvent: false\n  };\n\n  form._updateTreeValidity =\n  /**\n  * @param {?=} __0\n  * @return {?}\n  */\n  ({\n    emitEvent\n  } = {\n    emitEvent: true\n  }) => updateValidityArgs = {\n    called: true,\n    emitEvent: emitEvent || updateValidityArgs.emitEvent\n  };\n\n  action();\n  updateValidityArgs.called && updateValidity({\n    emitEvent: updateValidityArgs.emitEvent\n  });\n  form._updateTreeValidity = updateValidity;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst FORMLY_CONFIG = new InjectionToken('FORMLY_CONFIG');\n/**\n * Maintains list of formly field directive types. This can be used to register new field templates.\n */\n\nclass FormlyConfig {\n  constructor() {\n    this.types = {};\n    this.validators = {};\n    this.wrappers = {};\n    this.messages = {};\n    this.templateManipulators = {\n      preWrapper: [],\n      postWrapper: []\n    };\n    this.extras = {\n      checkExpressionOn: 'changeDetectionCheck',\n      lazyRender: false,\n      showError:\n      /**\n      * @param {?} field\n      * @return {?}\n      */\n      function (field) {\n        return field.formControl && field.formControl.invalid && (field.formControl.touched || field.options.parentForm && field.options.parentForm.submitted || !!(field.field.validation && field.field.validation.show));\n      }\n    };\n    this.extensions = {};\n  }\n  /**\n   * @param {?} config\n   * @return {?}\n   */\n\n\n  addConfig(config) {\n    if (config.types) {\n      config.types.forEach(\n      /**\n      * @param {?} type\n      * @return {?}\n      */\n      type => this.setType(type));\n    }\n\n    if (config.validators) {\n      config.validators.forEach(\n      /**\n      * @param {?} validator\n      * @return {?}\n      */\n      validator => this.setValidator(validator));\n    }\n\n    if (config.wrappers) {\n      config.wrappers.forEach(\n      /**\n      * @param {?} wrapper\n      * @return {?}\n      */\n      wrapper => this.setWrapper(wrapper));\n    }\n\n    if (config.manipulators) {\n      console.warn(`NgxFormly: passing 'manipulators' config is deprecated, use custom extension instead.`);\n      config.manipulators.forEach(\n      /**\n      * @param {?} manipulator\n      * @return {?}\n      */\n      manipulator => this.setManipulator(manipulator));\n    }\n\n    if (config.validationMessages) {\n      config.validationMessages.forEach(\n      /**\n      * @param {?} validation\n      * @return {?}\n      */\n      validation => this.addValidatorMessage(validation.name, validation.message));\n    }\n\n    if (config.extensions) {\n      config.extensions.forEach(\n      /**\n      * @param {?} c\n      * @return {?}\n      */\n      c => this.extensions[c.name] = c.extension);\n    }\n\n    if (config.extras) {\n      this.extras = Object.assign({}, this.extras, config.extras);\n    }\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  setType(options) {\n    if (Array.isArray(options)) {\n      options.forEach(\n      /**\n      * @param {?} option\n      * @return {?}\n      */\n      option => this.setType(option));\n    } else {\n      if (!this.types[options.name]) {\n        this.types[options.name] =\n        /** @type {?} */\n        {\n          name: options.name\n        };\n      }\n\n      ['component', 'extends', 'defaultOptions', 'wrappers'].forEach(\n      /**\n      * @param {?} prop\n      * @return {?}\n      */\n      prop => {\n        if (options.hasOwnProperty(prop)) {\n          this.types[options.name][prop] = options[prop];\n        }\n      });\n    }\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  getType(name) {\n    if (!this.types[name]) {\n      throw new Error(`[Formly Error] The type \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n    }\n\n    this.mergeExtendedType(name);\n    return this.types[name];\n  }\n  /**\n   * @param {?=} field\n   * @return {?}\n   */\n\n\n  getMergedField(field = {}) {\n    /** @type {?} */\n    const type = this.getType(field.type);\n\n    if (type.defaultOptions) {\n      reverseDeepMerge(field, type.defaultOptions);\n    }\n    /** @type {?} */\n\n\n    const extendDefaults = type.extends && this.getType(type.extends).defaultOptions;\n\n    if (extendDefaults) {\n      reverseDeepMerge(field, extendDefaults);\n    }\n\n    if (field && field.optionsTypes) {\n      field.optionsTypes.forEach(\n      /**\n      * @param {?} option\n      * @return {?}\n      */\n      option => {\n        /** @type {?} */\n        const defaultOptions = this.getType(option).defaultOptions;\n\n        if (defaultOptions) {\n          reverseDeepMerge(field, defaultOptions);\n        }\n      });\n    }\n    /** @type {?} */\n\n\n    const componentRef = this.resolveFieldTypeRef(field);\n\n    if (componentRef && componentRef.instance && componentRef.instance.defaultOptions) {\n      reverseDeepMerge(field, componentRef.instance.defaultOptions);\n    }\n\n    if (!field.wrappers && type.wrappers) {\n      field.wrappers = [...type.wrappers];\n    }\n  }\n  /**\n   * \\@internal\n   * @param {?=} field\n   * @return {?}\n   */\n\n\n  resolveFieldTypeRef(field = {}) {\n    if (!field.type) {\n      return null;\n    }\n    /** @type {?} */\n\n\n    const type = this.getType(field.type);\n\n    if (!type.component || type['_componentRef']) {\n      return type['_componentRef'];\n    }\n\n    const {\n      _resolver,\n      _injector\n    } = field.parent.options;\n    /** @type {?} */\n\n    const componentRef = _resolver.resolveComponentFactory(type.component).create(_injector);\n\n    defineHiddenProp(type, '_componentRef', componentRef);\n    componentRef.destroy();\n    return type['_componentRef'];\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  setWrapper(options) {\n    this.wrappers[options.name] = options;\n\n    if (options.types) {\n      options.types.forEach(\n      /**\n      * @param {?} type\n      * @return {?}\n      */\n      type => {\n        this.setTypeWrapper(type, options.name);\n      });\n    }\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  getWrapper(name) {\n    if (!this.wrappers[name]) {\n      throw new Error(`[Formly Error] The wrapper \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n    }\n\n    return this.wrappers[name];\n  }\n  /**\n   * @param {?} type\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  setTypeWrapper(type, name) {\n    if (!this.types[type]) {\n      this.types[type] =\n      /** @type {?} */\n      {};\n    }\n\n    if (!this.types[type].wrappers) {\n      this.types[type].wrappers = [];\n    }\n\n    if (this.types[type].wrappers.indexOf(name) === -1) {\n      this.types[type].wrappers.push(name);\n    }\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  setValidator(options) {\n    this.validators[options.name] = options;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  getValidator(name) {\n    if (!this.validators[name]) {\n      throw new Error(`[Formly Error] The validator \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n    }\n\n    return this.validators[name];\n  }\n  /**\n   * @param {?} name\n   * @param {?} message\n   * @return {?}\n   */\n\n\n  addValidatorMessage(name, message) {\n    this.messages[name] = message;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  getValidatorMessage(name) {\n    return this.messages[name];\n  }\n  /**\n   * @param {?} manipulator\n   * @return {?}\n   */\n\n\n  setManipulator(manipulator) {\n    new manipulator.class()[manipulator.method](this);\n  }\n  /**\n   * @private\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  mergeExtendedType(name) {\n    if (!this.types[name].extends) {\n      return;\n    }\n    /** @type {?} */\n\n\n    const extendedType = this.getType(this.types[name].extends);\n\n    if (!this.types[name].component) {\n      this.types[name].component = extendedType.component;\n    }\n\n    if (!this.types[name].wrappers) {\n      this.types[name].wrappers = extendedType.wrappers;\n    }\n  }\n\n}\n\nFormlyConfig.ɵfac = function FormlyConfig_Factory(t) {\n  return new (t || FormlyConfig)();\n};\n\nFormlyConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: FormlyConfig,\n  factory: FormlyConfig.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nFormlyConfig.ngInjectableDef = defineInjectable({\n  factory: function FormlyConfig_Factory() {\n    return new FormlyConfig();\n  },\n  token: FormlyConfig,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass FormlyFormBuilder {\n  /**\n   * @param {?} formlyConfig\n   * @param {?} componentFactoryResolver\n   * @param {?} injector\n   */\n  constructor(formlyConfig, componentFactoryResolver, injector) {\n    this.formlyConfig = formlyConfig;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.injector = injector;\n  }\n  /**\n   * @param {?} formControl\n   * @param {?=} fieldGroup\n   * @param {?=} model\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  buildForm(formControl, fieldGroup = [], model, options) {\n    if (!this.formlyConfig.extensions.core) {\n      throw new Error('NgxFormly: missing `forRoot()` call. use `forRoot()` when registering the `FormlyModule`.');\n    }\n    /** @type {?} */\n\n\n    const field = {\n      fieldGroup,\n      model,\n      formControl,\n      options: this._setOptions(options)\n    };\n    reduceFormUpdateValidityCalls(formControl,\n    /**\n    * @return {?}\n    */\n    () => this._buildForm(field));\n\n    field.options._checkField(field, true);\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  _buildForm(field) {\n    this.getExtensions().forEach(\n    /**\n    * @param {?} extension\n    * @return {?}\n    */\n    extension => extension.prePopulate && extension.prePopulate(field));\n    this.getExtensions().forEach(\n    /**\n    * @param {?} extension\n    * @return {?}\n    */\n    extension => extension.onPopulate && extension.onPopulate(field));\n\n    if (field.fieldGroup) {\n      field.fieldGroup.forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => this._buildForm(f));\n    }\n\n    this.getExtensions().forEach(\n    /**\n    * @param {?} extension\n    * @return {?}\n    */\n    extension => extension.postPopulate && extension.postPopulate(field));\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  getExtensions() {\n    return Object.keys(this.formlyConfig.extensions).map(\n    /**\n    * @param {?} name\n    * @return {?}\n    */\n    name => this.formlyConfig.extensions[name]);\n  }\n  /**\n   * @private\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  _setOptions(options) {\n    options = options || {};\n    options.formState = options.formState || {};\n\n    if (!options.showError) {\n      options.showError = this.formlyConfig.extras.showError;\n    }\n\n    if (!options.fieldChanges) {\n      defineHiddenProp(options, 'fieldChanges', new Subject());\n    }\n\n    if (!options._resolver) {\n      defineHiddenProp(options, '_resolver', this.componentFactoryResolver);\n    }\n\n    if (!options._injector) {\n      defineHiddenProp(options, '_injector', this.injector);\n    }\n\n    if (!options._hiddenFieldsForCheck) {\n      options._hiddenFieldsForCheck = [];\n    }\n\n    if (!options._markForCheck) {\n      options._markForCheck =\n      /**\n      * @param {?} field\n      * @return {?}\n      */\n      field => {\n        if (field._componentRefs) {\n          field._componentRefs.forEach(\n          /**\n          * @param {?} ref\n          * @return {?}\n          */\n          ref => {\n            // NOTE: we cannot use ref.changeDetectorRef, see https://github.com/ngx-formly/ngx-formly/issues/2191\n\n            /** @type {?} */\n            const changeDetectorRef = ref.injector.get(ChangeDetectorRef);\n            changeDetectorRef.markForCheck();\n          });\n        }\n\n        if (field.fieldGroup) {\n          field.fieldGroup.forEach(\n          /**\n          * @param {?} f\n          * @return {?}\n          */\n          f => options._markForCheck(f));\n        }\n      };\n    }\n\n    if (!options._buildField) {\n      options._buildField =\n      /**\n      * @param {?} field\n      * @return {?}\n      */\n      field => {\n        this.buildForm(field.form, field.fieldGroup, field.model, field.options);\n        return field;\n      };\n    }\n\n    return options;\n  }\n\n}\n\nFormlyFormBuilder.ɵfac = function FormlyFormBuilder_Factory(t) {\n  return new (t || FormlyFormBuilder)(ɵngcc0.ɵɵinject(FormlyConfig), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n};\n\nFormlyFormBuilder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: FormlyFormBuilder,\n  factory: FormlyFormBuilder.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\n/** @nocollapse */\nFormlyFormBuilder.ngInjectableDef = defineInjectable({\n  factory: function FormlyFormBuilder_Factory() {\n    return new FormlyFormBuilder(inject(FormlyConfig), inject(ComponentFactoryResolver), inject(INJECTOR));\n  },\n  token: FormlyFormBuilder,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} field\n * @param {?=} emitEvent\n * @return {?}\n */\n\n\nfunction unregisterControl(field, emitEvent = false) {\n  /** @type {?} */\n  const form =\n  /** @type {?} */\n  field.formControl.parent;\n\n  if (!form) {\n    return;\n  }\n  /** @type {?} */\n\n\n  const control = field.formControl;\n  /** @type {?} */\n\n  const opts = {\n    emitEvent\n  };\n\n  if (form instanceof FormArray) {\n    /** @type {?} */\n    const key = form.controls.findIndex(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    c => c === control);\n\n    if (key !== -1) {\n      updateControl(form, opts,\n      /**\n      * @return {?}\n      */\n      () => form.removeAt(key));\n    }\n  } else if (form instanceof FormGroup) {\n    /** @type {?} */\n    const paths = getKeyPath(field);\n    /** @type {?} */\n\n    const key = paths[paths.length - 1];\n\n    if (form.get([key]) === control) {\n      updateControl(form, opts,\n      /**\n      * @return {?}\n      */\n      () => form.removeControl(key));\n    }\n  }\n\n  control.setParent(null);\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction findControl(field) {\n  if (field.formControl) {\n    return field.formControl;\n  }\n\n  if (field['shareFormControl'] === false) {\n    return null;\n  }\n  /** @type {?} */\n\n\n  const form =\n  /** @type {?} */\n  field.parent.formControl;\n  return form ? form.get(getKeyPath(field)) : null;\n}\n/**\n * @param {?} field\n * @param {?=} control\n * @param {?=} emitEvent\n * @return {?}\n */\n\n\nfunction registerControl(field, control, emitEvent = false) {\n  control = control || field.formControl;\n\n  if (!control['_fields']) {\n    defineHiddenProp(control, '_fields', []);\n  }\n\n  if (control['_fields'].indexOf(field) === -1) {\n    control['_fields'].push(field);\n  }\n\n  if (!field.formControl && control) {\n    defineHiddenProp(field, 'formControl', control);\n    control.setValidators(null);\n    control.setAsyncValidators(null);\n    field.templateOptions.disabled = !!field.templateOptions.disabled;\n    wrapProperty(field.templateOptions, 'disabled',\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    ({\n      firstChange,\n      currentValue\n    }) => {\n      if (!firstChange) {\n        currentValue ? field.formControl.disable() : field.formControl.enable();\n      }\n    });\n\n    if (control.registerOnDisabledChange) {\n      control.registerOnDisabledChange(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      value => {\n        field.templateOptions['___$disabled'] = value; // TODO remove in V6\n\n        field.options && field.options._markForCheck(field);\n      });\n    }\n  }\n  /** @type {?} */\n\n\n  let parent =\n  /** @type {?} */\n  field.parent.formControl;\n\n  if (!parent || !field.key) {\n    return;\n  }\n  /** @type {?} */\n\n\n  const paths = getKeyPath(field);\n  /** @type {?} */\n\n  const value = getFieldValue(field);\n\n  if (!(isNullOrUndefined(control.value) && isNullOrUndefined(value)) && control.value !== value && control instanceof FormControl) {\n    control.patchValue(value);\n  }\n\n  for (let i = 0; i < paths.length - 1; i++) {\n    /** @type {?} */\n    const path = paths[i];\n\n    if (!parent.get([path])) {\n      updateControl(parent, {\n        emitEvent\n      },\n      /**\n      * @return {?}\n      */\n      () => parent.setControl(path, new FormGroup({})));\n    }\n\n    parent =\n    /** @type {?} */\n    parent.get([path]);\n  }\n  /** @type {?} */\n\n\n  const key = paths[paths.length - 1];\n\n  if (!field._hide && parent.get([key]) !== control) {\n    updateControl(parent, {\n      emitEvent\n    },\n    /**\n    * @return {?}\n    */\n    () => parent.setControl(key, control));\n  }\n}\n/**\n * @param {?} c\n * @return {?}\n */\n\n\nfunction updateValidity(c) {\n  /** @type {?} */\n  const status = c.status;\n  c.updateValueAndValidity({\n    emitEvent: false\n  });\n\n  if (status !== c.status) {\n    /** @type {?} */\n    c.statusChanges.emit(c.status);\n  }\n}\n/**\n * @param {?} form\n * @param {?} opts\n * @param {?} action\n * @return {?}\n */\n\n\nfunction updateControl(form, opts, action) {\n  /**\n   *  workaround for https://github.com/angular/angular/issues/27679\n   */\n  if (form instanceof FormGroup && !form['__patchForEachChild']) {\n    defineHiddenProp(form, '__patchForEachChild', true);\n\n    /** @type {?} */\n    form._forEachChild =\n    /**\n    * @param {?} cb\n    * @return {?}\n    */\n    cb => {\n      Object.keys(form.controls).forEach(\n      /**\n      * @param {?} k\n      * @return {?}\n      */\n      k => form.controls[k] && cb(form.controls[k], k));\n    };\n  }\n  /**\n   * workaround for https://github.com/angular/angular/issues/20439\n   * @type {?}\n   */\n\n\n  const updateValueAndValidity = form.updateValueAndValidity.bind(form);\n\n  if (opts.emitEvent === false) {\n    form.updateValueAndValidity =\n    /**\n    * @param {?} opts\n    * @return {?}\n    */\n    opts => {\n      updateValueAndValidity(Object.assign({}, opts || {}, {\n        emitEvent: false\n      }));\n    };\n  }\n\n  action();\n\n  if (opts.emitEvent === false) {\n    form.updateValueAndValidity = updateValueAndValidity;\n  }\n}\n/**\n * @param {?} form\n * @return {?}\n */\n\n\nfunction clearControl(form) {\n  form['_fields'] && delete form['_fields'];\n\n  if (form instanceof FormGroup || form instanceof FormArray) {\n    Object.keys(form.controls).forEach(\n    /**\n    * @param {?} k\n    * @return {?}\n    */\n    k => clearControl(form.controls[k]));\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet FormlyForm = /*#__PURE__*/(() => {\n  class FormlyForm {\n    /**\n     * @param {?} formlyBuilder\n     * @param {?} formlyConfig\n     * @param {?} ngZone\n     * @param {?} immutable\n     * @param {?} parentFormGroup\n     */\n    constructor(formlyBuilder, formlyConfig, ngZone, // tslint:disable-next-line\n    immutable, parentFormGroup) {\n      this.formlyBuilder = formlyBuilder;\n      this.formlyConfig = formlyConfig;\n      this.ngZone = ngZone;\n      this.parentFormGroup = parentFormGroup;\n      this.modelChange = new EventEmitter();\n      this.immutable = false;\n      this._modelChangeValue = {};\n      this.modelChangeSubs = [];\n      this.modelChange$ = new Subject();\n      this.modelChangeSub = this.modelChange$.pipe(switchMap(\n      /**\n      * @return {?}\n      */\n      () => this.ngZone.onStable.asObservable().pipe(take(1)))).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this.ngZone.runGuarded(\n      /**\n      * @return {?}\n      */\n      () => {\n        // runGuarded is used to keep the expression changes in-sync\n        // https://github.com/ngx-formly/ngx-formly/issues/2095\n        this.checkExpressionChange();\n        this.modelChange.emit(this._modelChangeValue = clone(this.model));\n      }));\n\n      if (immutable !== null) {\n        console.warn(`NgxFormly: passing 'immutable' attribute to 'formly-form' component is deprecated since v5.5, enable immutable mode through NgModule declaration instead.`);\n      }\n\n      this.immutable = immutable !== null || !!formlyConfig.extras.immutable;\n    }\n    /**\n     * @param {?} model\n     * @return {?}\n     */\n\n\n    set model(model) {\n      this._model = this.immutable ? clone(model) : model;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get model() {\n      if (!this._model) {\n        this._model = {};\n      }\n\n      return this._model;\n    }\n    /**\n     * @param {?} fields\n     * @return {?}\n     */\n\n\n    set fields(fields) {\n      this._fields = this.immutable ? clone(fields) : fields;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get fields() {\n      return this._fields || [];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    set options(options) {\n      this._options = this.immutable ? clone(options) : options;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get options() {\n      return this._options;\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n\n\n    set content(content) {\n      if (content) {\n        /** @type {?} */\n        let hasContent = false;\n        /** @type {?} */\n\n        let node = content.nativeElement.nextSibling;\n\n        while (node && !hasContent) {\n          if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim() !== '') {\n            hasContent = true;\n          }\n\n          node = node.nextSibling;\n        }\n\n        if (hasContent) {\n          console.warn(`NgxFormly: content projection for 'formly-form' component is deprecated since v5.5, you should avoid passing content inside the 'formly-form' tag.`);\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      if (this.formlyConfig.extras.checkExpressionOn === 'changeDetectionCheck') {\n        this.checkExpressionChange();\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      // https://github.com/ngx-formly/ngx-formly/issues/2294\n      if (changes.model && this.field) {\n        this.field.model = this.model;\n      }\n\n      if (changes.fields && this.form) {\n        clearControl(this.form);\n      }\n\n      if (changes.fields || changes.form || changes.model && this._modelChangeValue !== changes.model.currentValue) {\n        this.form = this.form || new FormGroup({});\n        this.setOptions();\n        this.options.updateInitialValue();\n        this.clearModelSubscriptions();\n        this.formlyBuilder.buildForm(this.form, this.fields, this.model, this.options);\n        this.trackModelChanges(this.fields);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.modelChangeSub.unsubscribe();\n      this.clearModelSubscriptions();\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n\n\n    changeModel({\n      key,\n      value,\n      field\n    }) {\n      assignFieldValue(field, value);\n      this.modelChange$.next();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    setOptions() {\n      if (!this.options) {\n        this.options = {};\n      }\n\n      if (!this.options.resetModel) {\n        this.options.resetModel =\n        /**\n        * @param {?=} model\n        * @return {?}\n        */\n        model => {\n          model = clone(isNullOrUndefined(model) ?\n          /** @type {?} */\n          this.options._initialModel : model);\n\n          if (this.model) {\n            Object.keys(this.model).forEach(\n            /**\n            * @param {?} k\n            * @return {?}\n            */\n            k => delete this.model[k]);\n            Object.assign(this.model, model || {});\n          }\n\n          /** @type {?} */\n          this.options._buildForm(); // we should call `NgForm::resetForm` to ensure changing `submitted` state after resetting form\n          // but only when the current component is a root one.\n\n\n          if (this.options.parentForm && this.options.parentForm.control === this.form) {\n            this.options.parentForm.resetForm(this.model);\n          } else {\n            this.form.reset(this.model);\n          }\n        };\n      }\n\n      if (!this.options.parentForm && this.parentFormGroup) {\n        defineHiddenProp(this.options, 'parentForm', this.parentFormGroup);\n        wrapProperty(this.options.parentForm, 'submitted',\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ({\n          firstChange\n        }) => {\n          if (!firstChange) {\n            this.checkExpressionChange();\n\n            /** @type {?} */\n            this.options._markForCheck({\n              fieldGroup: this.fields,\n              model: this.model,\n              formControl: this.form,\n              options: this.options\n            });\n          }\n        });\n      }\n\n      if (!this.options.updateInitialValue) {\n        this.options.updateInitialValue =\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        this.options._initialModel = clone(this.model);\n      }\n\n      if (!\n      /** @type {?} */\n      this.options._buildForm) {\n        /** @type {?} */\n        this.options._buildForm =\n        /**\n        * @param {?=} emitModelChange\n        * @return {?}\n        */\n        (emitModelChange = false) => {\n          this.clearModelSubscriptions();\n          this.formlyBuilder.buildForm(this.form, this.fields, this.model, this.options);\n          this.trackModelChanges(this.fields);\n\n          if (emitModelChange) {\n            this.modelChange.emit(this._modelChangeValue = clone(this.model));\n          }\n        };\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    checkExpressionChange() {\n      if (this.options &&\n      /** @type {?} */\n      this.options._checkField) {\n        /** @type {?} */\n        this.options._checkField({\n          fieldGroup: this.fields,\n          model: this.model,\n          formControl: this.form,\n          options: this.options\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} fields\n     * @param {?=} rootKey\n     * @return {?}\n     */\n\n\n    trackModelChanges(fields, rootKey = []) {\n      fields.forEach(\n      /**\n      * @param {?} field\n      * @return {?}\n      */\n      field => {\n        if (field.key && !field.fieldGroup && field.formControl) {\n          /** @type {?} */\n          const control = field.formControl;\n          /** @type {?} */\n\n          let valueChanges = control.valueChanges.pipe(distinctUntilChanged(\n          /**\n          * @param {?} x\n          * @param {?} y\n          * @return {?}\n          */\n          (x, y) => {\n            if (x !== y || Array.isArray(x) || isObject(x)) {\n              return false;\n            }\n\n            return true;\n          }));\n          const {\n            updateOn,\n            debounce\n          } = field.modelOptions;\n\n          if ((!updateOn || updateOn === 'change') && debounce && debounce.default > 0) {\n            valueChanges = control.valueChanges.pipe(debounceTime(debounce.default));\n          }\n\n          this.modelChangeSubs.push(valueChanges.subscribe(\n          /**\n          * @param {?} value\n          * @return {?}\n          */\n          value => {\n            // workaround for https://github.com/angular/angular/issues/13792\n            if (control instanceof FormControl && control['_fields'] && control['_fields'].length > 1) {\n              control.patchValue(value, {\n                emitEvent: false,\n                onlySelf: true\n              });\n            }\n\n            if (field.parsers && field.parsers.length > 0) {\n              field.parsers.forEach(\n              /**\n              * @param {?} parserFn\n              * @return {?}\n              */\n              parserFn => value = parserFn(value));\n            }\n\n            this.changeModel({\n              key: [...rootKey, ...getKeyPath(field)].join('.'),\n              value,\n              field\n            });\n          })); // workaround for v5 (https://github.com/ngx-formly/ngx-formly/issues/2061)\n\n          /** @type {?} */\n\n          const observers = control.valueChanges['observers'];\n\n          if (observers && observers.length > 1) {\n            observers.unshift(observers.pop());\n          }\n        }\n\n        if (field.fieldGroup && field.fieldGroup.length > 0) {\n          this.trackModelChanges(field.fieldGroup, field.key ? [...rootKey, ...getKeyPath(field)] : rootKey);\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    clearModelSubscriptions() {\n      this.modelChangeSubs.forEach(\n      /**\n      * @param {?} sub\n      * @return {?}\n      */\n      sub => sub.unsubscribe());\n      this.modelChangeSubs = [];\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get field() {\n      return this.fields && this.fields[0] && this.fields[0].parent;\n    }\n\n  }\n\n  FormlyForm.ɵfac = function FormlyForm_Factory(t) {\n    return new (t || FormlyForm)(ɵngcc0.ɵɵdirectiveInject(FormlyFormBuilder), ɵngcc0.ɵɵdirectiveInject(FormlyConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵinjectAttribute('immutable'), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FormGroupDirective, 8));\n  };\n\n  FormlyForm.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: FormlyForm,\n    selectors: [[\"formly-form\"]],\n    viewQuery: function FormlyForm_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);\n      }\n    },\n    inputs: {\n      model: \"model\",\n      fields: \"fields\",\n      options: \"options\",\n      form: \"form\"\n    },\n    outputs: {\n      modelChange: \"modelChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([FormlyFormBuilder]), ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 1,\n    consts: [[\"hide-deprecation\", \"\", 3, \"form\", \"options\", \"model\", \"field\", 4, \"ngFor\", \"ngForOf\"], [\"content\", \"\"], [\"hide-deprecation\", \"\", 3, \"form\", \"options\", \"model\", \"field\"]],\n    template: function FormlyForm_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, FormlyForm_formly_field_0_Template, 1, 4, \"formly-field\", 0);\n        ɵngcc0.ɵɵelementContainerStart(1, null, 1);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.fields);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgForOf, FormlyField];\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return FormlyForm;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet FormlyField = /*#__PURE__*/(() => {\n  class FormlyField {\n    /**\n     * @param {?} formlyConfig\n     * @param {?} renderer\n     * @param {?} resolver\n     * @param {?} elementRef\n     * @param {?} hideDeprecation\n     */\n    constructor(formlyConfig, renderer, resolver, elementRef, // tslint:disable-next-line\n    hideDeprecation) {\n      this.formlyConfig = formlyConfig;\n      this.renderer = renderer;\n      this.resolver = resolver;\n      this.elementRef = elementRef;\n      this.warnDeprecation = false;\n      this.modelChange = new EventEmitter();\n      this.hostObservers = [];\n      this.componentRefs = [];\n      this.hooksObservers = [];\n      this.detectFieldBuild = false;\n      this.warnDeprecation = hideDeprecation === null;\n    }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n\n\n    set model(m) {\n      this.warnDeprecation && console.warn(`NgxFormly: passing 'model' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @param {?} form\n     * @return {?}\n     */\n\n\n    set form(form) {\n      this.warnDeprecation && console.warn(`NgxFormly: passing 'form' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    set options(options) {\n      this.warnDeprecation && console.warn(`NgxFormly: passing 'options' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentInit() {\n      this.triggerHook('afterContentInit');\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentChecked() {\n      this.triggerHook('afterContentChecked');\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this.triggerHook('afterViewInit');\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewChecked() {\n      this.triggerHook('afterViewChecked');\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      this.triggerHook('doCheck');\n\n      if (this.detectFieldBuild && this.field && this.field.options) {\n        this.render();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.triggerHook('onInit');\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.triggerHook('onChanges', changes);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.resetRefs(this.field);\n      this.hostObservers.forEach(\n      /**\n      * @param {?} unsubscribe\n      * @return {?}\n      */\n      unsubscribe => unsubscribe());\n      this.hooksObservers.forEach(\n      /**\n      * @param {?} unsubscribe\n      * @return {?}\n      */\n      unsubscribe => unsubscribe());\n      this.triggerHook('onDestroy');\n    }\n    /**\n     * @private\n     * @param {?} containerRef\n     * @param {?} f\n     * @param {?=} wrappers\n     * @return {?}\n     */\n\n\n    renderField(containerRef, f, wrappers = []) {\n      if (this.containerRef === containerRef) {\n        this.resetRefs(this.field);\n        this.containerRef.clear();\n        wrappers = this.field ? this.field.wrappers : [];\n      }\n\n      if (wrappers && wrappers.length > 0) {\n        const [wrapper, ...wps] = wrappers;\n        const {\n          component\n        } = this.formlyConfig.getWrapper(wrapper);\n        /** @type {?} */\n\n        const ref = containerRef.createComponent(this.resolver.resolveComponentFactory(component));\n        this.attachComponentRef(ref, f);\n        wrapProperty(ref.instance, 'fieldComponent',\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        ({\n          firstChange,\n          previousValue,\n          currentValue\n        }) => {\n          if (currentValue) {\n            if (previousValue && previousValue['_lContainer'] === currentValue['_lContainer']) {\n              return;\n            }\n            /** @type {?} */\n\n\n            const viewRef = previousValue ? previousValue.detach() : null;\n\n            if (viewRef && !viewRef.destroyed) {\n              currentValue.insert(viewRef);\n            } else {\n              this.renderField(currentValue, f, wps);\n            }\n\n            !firstChange && ref.changeDetectorRef.detectChanges();\n          }\n        });\n      } else if (f && f.type) {\n        const {\n          component\n        } = this.formlyConfig.getType(f.type);\n        /** @type {?} */\n\n        const ref = containerRef.createComponent(this.resolver.resolveComponentFactory(component));\n        this.attachComponentRef(ref, f);\n      }\n    }\n    /**\n     * @private\n     * @param {?} name\n     * @param {?=} changes\n     * @return {?}\n     */\n\n\n    triggerHook(name, changes) {\n      if (this.field && this.field.hooks && this.field.hooks[name]) {\n        if (!changes || changes.field) {\n          /** @type {?} */\n          const r = this.field.hooks[name](this.field);\n\n          if (isObservable(r) && ['onInit', 'afterContentInit', 'afterViewInit'].indexOf(name) !== -1) {\n            /** @type {?} */\n            const sub = r.subscribe();\n            this.hooksObservers.push(\n            /**\n            * @return {?}\n            */\n            () => sub.unsubscribe());\n          }\n        }\n      }\n\n      if (this.field && this.field.lifecycle && this.field.lifecycle[name]) {\n        this.field.lifecycle[name](this.field.form, this.field, this.field.model, this.field.options);\n      }\n\n      if (name === 'onChanges' && changes.field) {\n        this.resetRefs(changes.field.previousValue);\n        this.render();\n      }\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} ref\n     * @param {?} field\n     * @return {?}\n     */\n\n\n    attachComponentRef(ref, field) {\n      this.componentRefs.push(ref);\n\n      field._componentRefs.push(ref);\n\n      Object.assign(ref.instance, {\n        field\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    render() {\n      if (!this.field) {\n        return;\n      } // require Formly build\n\n\n      if (!this.field.options) {\n        this.detectFieldBuild = true;\n        return;\n      }\n\n      this.detectFieldBuild = false;\n      this.hostObservers.forEach(\n      /**\n      * @param {?} unsubscribe\n      * @return {?}\n      */\n      unsubscribe => unsubscribe());\n      this.hostObservers = [wrapProperty(this.field, 'hide',\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        firstChange,\n        currentValue\n      }) => {\n        if (!this.formlyConfig.extras.lazyRender) {\n          firstChange && this.renderField(this.containerRef, this.field);\n\n          if (!firstChange || firstChange && currentValue) {\n            this.renderer.setStyle(this.elementRef.nativeElement, 'display', currentValue ? 'none' : '');\n          }\n        } else {\n          if (currentValue) {\n            this.containerRef.clear();\n          } else {\n            this.renderField(this.containerRef, this.field);\n          }\n        }\n      }), wrapProperty(this.field, 'className',\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        firstChange,\n        currentValue\n      }) => {\n        if (!firstChange || firstChange && currentValue) {\n          this.renderer.setAttribute(this.elementRef.nativeElement, 'class', currentValue);\n        }\n      })];\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n\n    resetRefs(field) {\n      if (field) {\n        if (field._componentRefs) {\n          field._componentRefs = field._componentRefs.filter(\n          /**\n          * @param {?} ref\n          * @return {?}\n          */\n          ref => this.componentRefs.indexOf(ref) === -1);\n        } else {\n          defineHiddenProp(this.field, '_componentRefs', []);\n        }\n      }\n\n      this.componentRefs = [];\n    }\n\n  }\n\n  FormlyField.ɵfac = function FormlyField_Factory(t) {\n    return new (t || FormlyField)(ɵngcc0.ɵɵdirectiveInject(FormlyConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('hide-deprecation'));\n  };\n\n  FormlyField.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: FormlyField,\n    selectors: [[\"formly-field\"]],\n    viewQuery: function FormlyField_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c2, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerRef = _t.first);\n      }\n    },\n    inputs: {\n      model: \"model\",\n      form: \"form\",\n      options: \"options\",\n      field: \"field\"\n    },\n    outputs: {\n      modelChange: \"modelChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"container\", \"\"]],\n    template: function FormlyField_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, FormlyField_ng_template_0_Template, 0, 0, \"ng-template\", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return FormlyField;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet FormlyAttributes = /*#__PURE__*/(() => {\n  class FormlyAttributes {\n    /**\n     * @param {?} renderer\n     * @param {?} elementRef\n     * @param {?} _document\n     */\n    constructor(renderer, elementRef, _document) {\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.uiAttributesCache = {};\n      this.uiAttributes = [...FORMLY_VALIDATORS, 'tabindex', 'placeholder', 'readonly', 'disabled', 'step'];\n      /**\n       * HostBinding doesn't register listeners conditionally which may produce some perf issues.\n       *\n       * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1991\n       */\n\n      this.uiEvents = {\n        listeners: [],\n        events: ['click', 'keyup', 'keydown', 'keypress']\n      };\n      this.document = _document;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get to() {\n      return this.field.templateOptions || {};\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get fieldAttrElements() {\n      return this.field && this.field['_elementRefs'] || [];\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.field) {\n        this.field.name && this.setAttribute('name', this.field.name);\n        this.uiEvents.listeners.forEach(\n        /**\n        * @param {?} listener\n        * @return {?}\n        */\n        listener => listener());\n        this.uiEvents.events.forEach(\n        /**\n        * @param {?} eventName\n        * @return {?}\n        */\n        eventName => {\n          if (this.to && this.to[eventName]) {\n            this.uiEvents.listeners.push(this.renderer.listen(this.elementRef.nativeElement, eventName,\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            e => this.to[eventName](this.field, e)));\n          }\n        });\n\n        if (this.to && this.to.attributes) {\n          wrapProperty(this.to, 'attributes',\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          ({\n            currentValue,\n            previousValue\n          }) => {\n            if (previousValue) {\n              Object.keys(previousValue).forEach(\n              /**\n              * @param {?} attr\n              * @return {?}\n              */\n              attr => this.removeAttribute(attr));\n            }\n\n            if (currentValue) {\n              Object.keys(currentValue).forEach(\n              /**\n              * @param {?} attr\n              * @return {?}\n              */\n              attr => {\n                if (currentValue[attr] != null) {\n                  this.setAttribute(attr, currentValue[attr]);\n                }\n              });\n            }\n          });\n        }\n\n        this.detachElementRef(changes.field.previousValue);\n        this.attachElementRef(changes.field.currentValue);\n\n        if (this.fieldAttrElements.length === 1) {\n          !this.id && this.field.id && this.setAttribute('id', this.field.id);\n          wrapProperty(this.field, 'focus',\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          ({\n            currentValue\n          }) => {\n            this.toggleFocus(currentValue);\n          });\n        }\n      }\n\n      if (changes.id) {\n        this.setAttribute('id', this.id);\n      }\n    }\n    /**\n     * We need to re-evaluate all the attributes on every change detection cycle, because\n     * by using a HostBinding we run into certain edge cases. This means that whatever logic\n     * is in here has to be super lean or we risk seriously damaging or destroying the performance.\n     *\n     * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1317\n     * Material issue: https://github.com/angular/components/issues/14024\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      this.uiAttributes.forEach(\n      /**\n      * @param {?} attr\n      * @return {?}\n      */\n      attr => {\n        /** @type {?} */\n        const value = this.to[attr];\n\n        if (this.uiAttributesCache[attr] !== value && (!this.to.attributes || !this.to.attributes.hasOwnProperty(attr.toLowerCase()))) {\n          this.uiAttributesCache[attr] = value;\n\n          if (value || value === 0) {\n            this.setAttribute(attr, value === true ? attr : `${value}`);\n          } else {\n            this.removeAttribute(attr);\n          }\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.uiEvents.listeners.forEach(\n      /**\n      * @param {?} listener\n      * @return {?}\n      */\n      listener => listener());\n      this.detachElementRef(this.field);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    toggleFocus(value) {\n      /** @type {?} */\n      const element = this.fieldAttrElements ? this.fieldAttrElements[0] : null;\n\n      if (!element || !element.nativeElement.focus) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const isFocused = !!this.document.activeElement && this.fieldAttrElements.some(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        nativeElement\n      }) => this.document.activeElement === nativeElement || nativeElement.contains(this.document.activeElement));\n\n      if (value && !isFocused) {\n        element.nativeElement.focus();\n      } else if (!value && isFocused) {\n        element.nativeElement.blur();\n      }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n\n    onFocus($event) {\n      this.field['___$focus'] = true;\n\n      if (this.to.focus) {\n        this.to.focus(this.field, $event);\n      }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n\n    onBlur($event) {\n      this.field['___$focus'] = false;\n\n      if (this.to.blur) {\n        this.to.blur(this.field, $event);\n      }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n\n    onChange($event) {\n      if (this.to.change) {\n        this.to.change(this.field, $event);\n      }\n\n      if (this.field.formControl) {\n        this.field.formControl.markAsDirty();\n      }\n    }\n    /**\n     * @private\n     * @param {?} f\n     * @return {?}\n     */\n\n\n    attachElementRef(f) {\n      if (!f) {\n        return;\n      }\n\n      if (f['_elementRefs'] && f['_elementRefs'].indexOf(this.elementRef) === -1) {\n        f['_elementRefs'].push(this.elementRef);\n      } else {\n        defineHiddenProp(f, '_elementRefs', [this.elementRef]);\n      }\n    }\n    /**\n     * @private\n     * @param {?} f\n     * @return {?}\n     */\n\n\n    detachElementRef(f) {\n      /** @type {?} */\n      const index = f && f['_elementRefs'] ? this.fieldAttrElements.indexOf(this.elementRef) : -1;\n\n      if (index !== -1) {\n        this.field['_elementRefs'].splice(index, 1);\n      }\n    }\n    /**\n     * @private\n     * @param {?} attr\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    setAttribute(attr, value) {\n      this.renderer.setAttribute(this.elementRef.nativeElement, attr, value);\n    }\n    /**\n     * @private\n     * @param {?} attr\n     * @return {?}\n     */\n\n\n    removeAttribute(attr) {\n      this.renderer.removeAttribute(this.elementRef.nativeElement, attr);\n    }\n\n  }\n\n  FormlyAttributes.ɵfac = function FormlyAttributes_Factory(t) {\n    return new (t || FormlyAttributes)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  FormlyAttributes.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FormlyAttributes,\n    selectors: [[\"\", \"formlyAttributes\", \"\"]],\n    hostBindings: function FormlyAttributes_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function FormlyAttributes_focus_HostBindingHandler($event) {\n          return ctx.onFocus($event);\n        })(\"blur\", function FormlyAttributes_blur_HostBindingHandler($event) {\n          return ctx.onBlur($event);\n        })(\"change\", function FormlyAttributes_change_HostBindingHandler($event) {\n          return ctx.onChange($event);\n        });\n      }\n    },\n    inputs: {\n      field: [\"formlyAttributes\", \"field\"],\n      id: \"id\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return FormlyAttributes;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n * @template F\n */\n\n\nlet FieldType = /*#__PURE__*/(() => {\n  class FieldType {\n    /**\n     * @return {?}\n     */\n    get model() {\n      return this.field.model;\n    }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n\n\n    set model(m) {\n      console.warn(`NgxFormly: passing 'model' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get form() {\n      return (\n        /** @type {?} */\n        this.field.parent.formControl\n      );\n    }\n    /**\n     * @param {?} form\n     * @return {?}\n     */\n\n\n    set form(form) {\n      console.warn(`NgxFormly: passing 'form' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get options() {\n      return this.field.options;\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    set options(options) {\n      console.warn(`NgxFormly: passing 'options' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get key() {\n      return this.field.key;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get formControl() {\n      return this.field.formControl;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get to() {\n      return this.field.templateOptions || {};\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get showError() {\n      return this.options.showError(this);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get id() {\n      return this.field.id;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get formState() {\n      return this.options.formState || {};\n    }\n\n  }\n\n  FieldType.ɵfac = function FieldType_Factory(t) {\n    return new (t || FieldType)();\n  };\n\n  FieldType.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FieldType,\n    inputs: {\n      model: \"model\",\n      form: \"form\",\n      options: \"options\",\n      field: \"field\"\n    }\n  });\n  return FieldType;\n})();\n\n/**\n * @deprecated use `FieldType` instead\n * @abstract\n */\nclass Field extends FieldType {\n  constructor() {\n    super();\n    console.warn(`NgxFormly: 'Field' has been renamed to 'FieldType', extend 'FieldType' instead.`);\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// TODO remove `selector` in V6\n// tslint:disable-next-line\n\n/**\n * @abstract\n * @template F\n */\n\n\nlet FieldArrayType = /*#__PURE__*/(() => {\n  class FieldArrayType extends FieldType {\n    /**\n     * @param {?=} builder\n     */\n    constructor(builder) {\n      super();\n      this.defaultOptions = {\n        defaultValue: []\n      };\n\n      if (builder instanceof FormlyFormBuilder) {\n        console.warn(`NgxFormly: passing 'FormlyFormBuilder' to '${this.constructor.name}' type is not required anymore, you may remove it!`);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get formControl() {\n      return (\n        /** @type {?} */\n        this.field.formControl\n      );\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n\n\n    onPopulate(field) {\n      if (!field.formControl && field.key) {\n        /** @type {?} */\n        const control = findControl(field);\n        registerControl(field, control ? control : new FormArray([], {\n          updateOn: field.modelOptions.updateOn\n        }));\n      }\n\n      field.fieldGroup = field.fieldGroup || [];\n      /** @type {?} */\n\n      const length = field.model ? field.model.length : 0;\n\n      if (field.fieldGroup.length > length) {\n        for (let i = field.fieldGroup.length - 1; i >= length; --i) {\n          unregisterControl(field.fieldGroup[i]);\n          field.fieldGroup.splice(i, 1);\n        }\n      }\n\n      for (let i = field.fieldGroup.length; i < length; i++) {\n        /** @type {?} */\n        const f = Object.assign({}, clone(field.fieldArray), {\n          key: `${i}`\n        });\n        field.fieldGroup.push(f);\n      }\n    }\n    /**\n     * @param {?=} i\n     * @param {?=} initialModel\n     * @param {?=} __2\n     * @return {?}\n     */\n\n\n    add(i, initialModel, {\n      markAsDirty\n    } = {\n      markAsDirty: true\n    }) {\n      i = isNullOrUndefined(i) ? this.field.fieldGroup.length : i;\n\n      if (!this.model) {\n        assignFieldValue(this.field, []);\n      }\n\n      this.model.splice(i, 0, initialModel ? clone(initialModel) : undefined);\n\n      /** @type {?} */\n      this.options._buildForm(true);\n\n      markAsDirty && this.formControl.markAsDirty();\n    }\n    /**\n     * @param {?} i\n     * @param {?=} __1\n     * @return {?}\n     */\n\n\n    remove(i, {\n      markAsDirty\n    } = {\n      markAsDirty: true\n    }) {\n      this.model.splice(i, 1);\n      unregisterControl(this.field.fieldGroup[i], true);\n      this.field.fieldGroup.splice(i, 1);\n      this.field.fieldGroup.forEach(\n      /**\n      * @param {?} f\n      * @param {?} key\n      * @return {?}\n      */\n      (f, key) => f.key = `${key}`);\n\n      /** @type {?} */\n      this.options._buildForm(true);\n\n      markAsDirty && this.formControl.markAsDirty();\n    }\n\n  }\n\n  FieldArrayType.ɵfac = function FieldArrayType_Factory(t) {\n    return new (t || FieldArrayType)(ɵngcc0.ɵɵdirectiveInject(FORMLY_CONFIG, 8));\n  };\n\n  FieldArrayType.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FieldArrayType,\n    selectors: [[\"fieldArray\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return FieldArrayType;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n * @template F\n */\n\n\nlet FieldWrapper = /*#__PURE__*/(() => {\n  class FieldWrapper extends FieldType {}\n\n  FieldWrapper.ɵfac = /*@__PURE__*/function () {\n    let ɵFieldWrapper_BaseFactory;\n    return function FieldWrapper_Factory(t) {\n      return (ɵFieldWrapper_BaseFactory || (ɵFieldWrapper_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FieldWrapper)))(t || FieldWrapper);\n    };\n  }();\n\n  FieldWrapper.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: FieldWrapper,\n    viewQuery: function FieldWrapper_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c3, 5, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fieldComponent = _t.first);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return FieldWrapper;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet FormlyGroup = /*#__PURE__*/(() => {\n  class FormlyGroup extends FieldType {\n    constructor() {\n      super(...arguments);\n      this.defaultOptions = {\n        defaultValue: {}\n      };\n    }\n\n  }\n\n  FormlyGroup.ɵfac = /*@__PURE__*/function () {\n    let ɵFormlyGroup_BaseFactory;\n    return function FormlyGroup_Factory(t) {\n      return (ɵFormlyGroup_BaseFactory || (ɵFormlyGroup_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FormlyGroup)))(t || FormlyGroup);\n    };\n  }();\n\n  FormlyGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: FormlyGroup,\n    selectors: [[\"formly-group\"]],\n    hostVars: 2,\n    hostBindings: function FormlyGroup_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(ctx.field.fieldGroupClassName || \"\");\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"field\", 4, \"ngFor\", \"ngForOf\"], [3, \"field\"]],\n    template: function FormlyGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, FormlyGroup_formly_field_0_Template, 1, 1, \"formly-field\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.field.fieldGroup);\n      }\n    },\n    directives: [ɵngcc2.NgForOf, FormlyField],\n    encapsulation: 2\n  });\n  return FormlyGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet FormlyValidationMessage = /*#__PURE__*/(() => {\n  class FormlyValidationMessage {\n    /**\n     * @param {?} formlyConfig\n     */\n    constructor(formlyConfig) {\n      this.formlyConfig = formlyConfig;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnChanges() {\n      this.errorMessage$ = this.field.formControl.statusChanges.pipe(startWith(null), switchMap(\n      /**\n      * @return {?}\n      */\n      () => isObservable(this.errorMessage) ? this.errorMessage : of(this.errorMessage)));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get errorMessage() {\n      /** @type {?} */\n      const fieldForm = this.field.formControl;\n\n      for (let error in fieldForm.errors) {\n        if (fieldForm.errors.hasOwnProperty(error)) {\n          /** @type {?} */\n          let message = this.formlyConfig.getValidatorMessage(error);\n\n          if (isObject(fieldForm.errors[error])) {\n            if (fieldForm.errors[error].errorPath) {\n              return;\n            }\n\n            if (fieldForm.errors[error].message) {\n              message = fieldForm.errors[error].message;\n            }\n          }\n\n          if (this.field.validation && this.field.validation.messages && this.field.validation.messages[error]) {\n            message = this.field.validation.messages[error];\n          }\n\n          if (this.field.validators && this.field.validators[error] && this.field.validators[error].message) {\n            message = this.field.validators[error].message;\n          }\n\n          if (this.field.asyncValidators && this.field.asyncValidators[error] && this.field.asyncValidators[error].message) {\n            message = this.field.asyncValidators[error].message;\n          }\n\n          if (typeof message === 'function') {\n            return message(fieldForm.errors[error], this.field);\n          }\n\n          return message;\n        }\n      }\n    }\n\n  }\n\n  FormlyValidationMessage.ɵfac = function FormlyValidationMessage_Factory(t) {\n    return new (t || FormlyValidationMessage)(ɵngcc0.ɵɵdirectiveInject(FormlyConfig));\n  };\n\n  FormlyValidationMessage.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: FormlyValidationMessage,\n    selectors: [[\"formly-validation-message\"]],\n    inputs: {\n      field: \"field\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 3,\n    template: function FormlyValidationMessage_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtext(0);\n        ɵngcc0.ɵɵpipe(1, \"async\");\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(1, 1, ctx.errorMessage$));\n      }\n    },\n    pipes: [ɵngcc2.AsyncPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return FormlyValidationMessage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet FormlyTemplateType = /*#__PURE__*/(() => {\n  class FormlyTemplateType extends FieldType {\n    /**\n     * @param {?} sanitizer\n     */\n    constructor(sanitizer) {\n      super();\n      this.sanitizer = sanitizer;\n      this.innerHtml = {\n        content: null,\n        template: null\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get template() {\n      if (this.field && this.field.template !== this.innerHtml.template) {\n        this.innerHtml = {\n          template: this.field.template,\n          content: this.to.safeHtml ? this.sanitizer.bypassSecurityTrustHtml(this.field.template) : this.field.template\n        };\n      }\n\n      return this.innerHtml.content;\n    }\n\n  }\n\n  FormlyTemplateType.ɵfac = function FormlyTemplateType_Factory(t) {\n    return new (t || FormlyTemplateType)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.DomSanitizer));\n  };\n\n  FormlyTemplateType.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: FormlyTemplateType,\n    selectors: [[\"formly-template\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"innerHtml\"]],\n    template: function FormlyTemplateType_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"innerHtml\", ctx.template, ɵngcc0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return FormlyTemplateType;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} expression\n * @param {?} argNames\n * @return {?}\n */\n\n\nfunction evalStringExpression(expression, argNames) {\n  try {\n    if (expression.indexOf('this.field') !== -1) {\n      console.warn(`NgxFormly: using 'this.field' in expressionProperties is deprecated since v5.1, use 'field' instead.`);\n    }\n\n    return (\n      /** @type {?} */\n      Function(...argNames, `return ${expression};`)\n    );\n  } catch (error) {\n    console.error(error);\n  }\n}\n/**\n * @param {?} expression\n * @param {?} thisArg\n * @param {?} argVal\n * @return {?}\n */\n\n\nfunction evalExpression(expression, thisArg, argVal) {\n  if (expression instanceof Function) {\n    return expression.apply(thisArg, argVal);\n  } else {\n    return expression ? true : false;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nclass FieldExpressionExtension {\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n  prePopulate(field) {\n    if (field.parent || field.options._checkField) {\n      return;\n    }\n    /** @type {?} */\n\n\n    let checkLocked = false;\n\n    field.options._checkField =\n    /**\n    * @param {?} f\n    * @param {?} ignoreCache\n    * @return {?}\n    */\n    (f, ignoreCache) => {\n      if (!checkLocked) {\n        checkLocked = true;\n        reduceFormUpdateValidityCalls(f.formControl,\n        /**\n        * @return {?}\n        */\n        () => this.checkField(f, ignoreCache));\n        checkLocked = false;\n      }\n    };\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  postPopulate(field) {\n    if (!field.parent || field._expressionProperties) {\n      return;\n    } // cache built expression\n\n\n    defineHiddenProp(field, '_expressionProperties', {});\n\n    if (field.expressionProperties) {\n      for (const key in field.expressionProperties) {\n        /** @type {?} */\n        const expressionProperty = field.expressionProperties[key];\n\n        if (typeof expressionProperty === 'string' || isFunction(expressionProperty)) {\n          field._expressionProperties[key] = {\n            expression: this._evalExpression(key, expressionProperty, key === 'templateOptions.disabled' && field.parent.expressionProperties && field.parent.expressionProperties.hasOwnProperty('templateOptions.disabled') ?\n            /**\n            * @return {?}\n            */\n            () => field.parent.templateOptions.disabled : undefined)\n          };\n\n          if (key === 'templateOptions.disabled') {\n            Object.defineProperty(field._expressionProperties[key], 'expressionValue', {\n              get:\n              /**\n              * @return {?}\n              */\n              () => field.templateOptions.disabled,\n              set:\n              /**\n              * @return {?}\n              */\n              () => {},\n              enumerable: true,\n              configurable: true\n            });\n          }\n        } else if (expressionProperty instanceof Observable) {\n          /** @type {?} */\n          const subscribe =\n          /**\n          * @return {?}\n          */\n          () =>\n          /** @type {?} */\n          expressionProperty.subscribe(\n          /**\n          * @param {?} v\n          * @return {?}\n          */\n          v => {\n            this.setExprValue(field, key, v);\n\n            if (field.options && field.options._markForCheck) {\n              field.options._markForCheck(field);\n            }\n          });\n          /** @type {?} */\n\n\n          let subscription = subscribe();\n          /** @type {?} */\n\n          const onInit = field.hooks.onInit;\n\n          field.hooks.onInit =\n          /**\n          * @return {?}\n          */\n          () => {\n            if (subscription === null) {\n              subscription = subscribe();\n            }\n\n            return onInit && onInit(field);\n          };\n          /** @type {?} */\n\n\n          const onDestroy = field.hooks.onDestroy;\n\n          field.hooks.onDestroy =\n          /**\n          * @return {?}\n          */\n          () => {\n            onDestroy && onDestroy(field);\n            subscription.unsubscribe();\n            subscription = null;\n          };\n        }\n      }\n    }\n\n    if (field.hideExpression) {\n      // delete hide value in order to force re-evaluate it in FormlyFormExpression.\n      delete field.hide;\n      field.hideExpression = this._evalExpression('hide', field.hideExpression,\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        let root = field.parent;\n\n        while (root.parent && !root.hide) {\n          root = root.parent;\n        }\n\n        return root.hide;\n      });\n    } else {\n      wrapProperty(field, 'hide',\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        currentValue,\n        firstChange\n      }) => {\n        field._hide = currentValue;\n\n        if (!firstChange || firstChange && currentValue === true) {\n          field.options._hiddenFieldsForCheck.push(field);\n        }\n      });\n    }\n  }\n  /**\n   * @private\n   * @param {?} prop\n   * @param {?} expression\n   * @param {?=} parentExpression\n   * @return {?}\n   */\n\n\n  _evalExpression(prop, expression, parentExpression) {\n    return (\n      /**\n      * @param {?} model\n      * @param {?} formState\n      * @param {?} field\n      * @return {?}\n      */\n      (model, formState, field) => {\n        try {\n          if (typeof expression === 'string') {\n            expression = evalStringExpression(expression, ['model', 'formState', 'field']);\n          }\n\n          if (typeof expression !== 'function') {\n            expression =\n            /**\n            * @return {?}\n            */\n            () => !!expression;\n          }\n\n          return parentExpression && parentExpression() || expression(model, formState, field);\n        } catch (error) {\n          error.message = `[Formly Error] [Expression \"${prop}\"] ${error.message}`;\n          throw error;\n        }\n      }\n    );\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?=} ignoreCache\n   * @return {?}\n   */\n\n\n  checkField(field, ignoreCache = false) {\n    /** @type {?} */\n    const fieldChanged = this._checkField(field, ignoreCache);\n\n    field.options._hiddenFieldsForCheck.sort(\n    /**\n    * @param {?} f\n    * @return {?}\n    */\n    f => f.hide ? -1 : 1).forEach(\n    /**\n    * @param {?} f\n    * @return {?}\n    */\n    f => this.toggleFormControl(f, !!f.hide, !ignoreCache));\n\n    field.options._hiddenFieldsForCheck = [];\n\n    if (fieldChanged) {\n      this.checkField(field);\n\n      if (field.options && field.options._markForCheck) {\n        field.options._markForCheck(field);\n      }\n    }\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?=} ignoreCache\n   * @return {?}\n   */\n\n\n  _checkField(field, ignoreCache = false) {\n    /** @type {?} */\n    let fieldChanged = false;\n    field.fieldGroup.forEach(\n    /**\n    * @param {?} f\n    * @return {?}\n    */\n    f => {\n      if (!f.options) {\n        return;\n      }\n\n      this.checkFieldExpressionChange(f, ignoreCache) && (fieldChanged = true);\n\n      if (this.checkFieldVisibilityChange(f, ignoreCache)) {\n        field.options._hiddenFieldsForCheck.push(f);\n\n        fieldChanged = true;\n      }\n\n      if (f.fieldGroup && f.fieldGroup.length > 0) {\n        this._checkField(f, ignoreCache) && (fieldChanged = true);\n      }\n    });\n    return fieldChanged;\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} ignoreCache\n   * @return {?}\n   */\n\n\n  checkFieldExpressionChange(field, ignoreCache) {\n    if (!field || !field._expressionProperties) {\n      return false;\n    }\n    /** @type {?} */\n\n\n    let markForCheck = false;\n    /** @type {?} */\n\n    const expressionProperties = field._expressionProperties;\n\n    for (const key in expressionProperties) {\n      /** @type {?} */\n      let expressionValue = evalExpression(expressionProperties[key].expression, {\n        field\n      }, [field.model, field.options.formState, field]);\n\n      if (key === 'templateOptions.disabled') {\n        expressionValue = !!expressionValue;\n      }\n\n      if (ignoreCache || expressionProperties[key].expressionValue !== expressionValue && (!isObject(expressionValue) || isObservable(expressionValue) || JSON.stringify(expressionValue) !== JSON.stringify(expressionProperties[key].expressionValue))) {\n        markForCheck = true;\n        expressionProperties[key].expressionValue = expressionValue;\n        this.setExprValue(field, key, expressionValue);\n      }\n    }\n\n    return markForCheck;\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} ignoreCache\n   * @return {?}\n   */\n\n\n  checkFieldVisibilityChange(field, ignoreCache) {\n    if (!field || isNullOrUndefined(field.hideExpression)) {\n      return false;\n    }\n    /** @type {?} */\n\n\n    const hideExpressionResult = !!evalExpression(field.hideExpression, {\n      field\n    }, [field.model, field.options.formState, field]);\n    /** @type {?} */\n\n    let markForCheck = false;\n\n    if (hideExpressionResult !== field.hide || ignoreCache) {\n      markForCheck = true; // toggle hide\n\n      field.hide = hideExpressionResult;\n      field.templateOptions.hidden = hideExpressionResult;\n    }\n\n    return markForCheck;\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  setDisabledState(field, value) {\n    if (field.fieldGroup) {\n      field.fieldGroup.filter(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => !f.expressionProperties || !f.expressionProperties.hasOwnProperty('templateOptions.disabled')).forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => this.setDisabledState(f, value));\n    }\n\n    if (field.key && field.templateOptions.disabled !== value) {\n      field.templateOptions.disabled = value;\n    }\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} hide\n   * @param {?} resetOnHide\n   * @return {?}\n   */\n\n\n  toggleFormControl(field, hide, resetOnHide) {\n    if (field.formControl && field.key) {\n      defineHiddenProp(field, '_hide', !!(hide || field.hide));\n      /** @type {?} */\n\n      const c = field.formControl;\n\n      if (c['_fields'] && c['_fields'].length > 1) {\n        updateValidity(c);\n      }\n\n      if (hide === true && (!c['_fields'] || c['_fields'].every(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => !!f._hide))) {\n        unregisterControl(field, true);\n\n        if (resetOnHide && field.resetOnHide) {\n          field.formControl.reset({\n            value: undefined,\n            disabled: field.formControl.disabled\n          });\n\n          if (field.fieldGroup) {\n            assignFieldValue(field, undefined);\n\n            if (field.formControl instanceof FormArray) {\n              field.fieldGroup.length = 0;\n            }\n          }\n        }\n      } else if (hide === false) {\n        if (field.resetOnHide && field.parent && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n          assignFieldValue(field, field.defaultValue);\n        }\n\n        registerControl(field, undefined, true);\n\n        if (field.resetOnHide && field.fieldArray && (field.fieldGroup || []).length !== (field.model || []).length) {\n          /** @type {?} */\n          field.options._buildForm(true);\n        }\n      }\n    }\n\n    if (field.fieldGroup) {\n      field.fieldGroup.filter(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => !f.hideExpression).forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => this.toggleFormControl(f, hide, resetOnHide));\n    }\n\n    if (field.options.fieldChanges) {\n      field.options.fieldChanges.next(\n      /** @type {?} */\n      {\n        field,\n        type: 'hidden',\n        value: hide\n      });\n    }\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} prop\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  setExprValue(field, prop, value) {\n    try {\n      /** @type {?} */\n      let target = field;\n      /** @type {?} */\n\n      const paths = prop.indexOf('[') === -1 ? prop.split('.') : prop.replace(/\\'|\\\"/g, '').split(/[[\\]]{1,2}/) // https://stackoverflow.com/a/20198206\n      .filter(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      v => v);\n      /** @type {?} */\n\n      const lastIndex = paths.length - 1;\n\n      for (let i = 0; i < lastIndex; i++) {\n        target = target[paths[i]];\n      }\n\n      target[paths[lastIndex]] = value;\n    } catch (error) {\n      error.message = `[Formly Error] [Expression \"${prop}\"] ${error.message}`;\n      throw error;\n    }\n\n    if (prop === 'templateOptions.disabled' && field.key) {\n      this.setDisabledState(field, value);\n    }\n\n    if (prop.indexOf('model.') === 0) {\n      /** @type {?} */\n      const path = prop.replace(/^model\\./, '');\n      /** @type {?} */\n\n      const control = field.key && prop === path ? field.formControl : field.parent.formControl.get(path);\n\n      if (control && !(isNullOrUndefined(control.value) && isNullOrUndefined(value)) && control.value !== value) {\n        control.patchValue(value);\n      }\n    }\n\n    this.emitExpressionChanges(field, prop, value);\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} property\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  emitExpressionChanges(field, property, value) {\n    if (!field.options.fieldChanges) {\n      return;\n    }\n\n    field.options.fieldChanges.next({\n      field: field,\n      type: 'expressionChanges',\n      property,\n      value\n    });\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nclass FieldValidationExtension {\n  /**\n   * @param {?} formlyConfig\n   */\n  constructor(formlyConfig) {\n    this.formlyConfig = formlyConfig;\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  onPopulate(field) {\n    this.initFieldValidation(field, 'validators');\n    this.initFieldValidation(field, 'asyncValidators');\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} type\n   * @return {?}\n   */\n\n\n  initFieldValidation(field, type) {\n    /** @type {?} */\n    const validators = [];\n\n    if (type === 'validators' && !(field.hasOwnProperty('fieldGroup') && !field.key)) {\n      validators.push(this.getPredefinedFieldValidation(field));\n    }\n\n    if (field[type]) {\n      for (const validatorName in field[type]) {\n        if (validatorName === 'validation' && !Array.isArray(field[type].validation)) {\n          field[type].validation = [field[type].validation];\n          console.warn(`NgxFormly(${field.key}): passing a non array value to the 'validation' is deprecated, pass an array instead`);\n        }\n\n        validatorName === 'validation' ? validators.push(...field[type].validation.map(\n        /**\n        * @param {?} v\n        * @return {?}\n        */\n        v => this.wrapNgValidatorFn(field, v))) : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));\n      }\n    }\n\n    defineHiddenProp(field, '_' + type, validators);\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  getPredefinedFieldValidation(field) {\n    /** @type {?} */\n    let VALIDATORS = [];\n    FORMLY_VALIDATORS.forEach(\n    /**\n    * @param {?} opt\n    * @return {?}\n    */\n    opt => wrapProperty(field.templateOptions, opt,\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    ({\n      currentValue,\n      firstChange\n    }) => {\n      VALIDATORS = VALIDATORS.filter(\n      /**\n      * @param {?} o\n      * @return {?}\n      */\n      o => o !== opt);\n\n      if (currentValue != null && currentValue !== false) {\n        VALIDATORS.push(opt);\n      }\n\n      if (!firstChange && field.formControl) {\n        updateValidity(field.formControl);\n      }\n    }));\n    return (\n      /**\n      * @param {?} control\n      * @return {?}\n      */\n      control => {\n        if (VALIDATORS.length === 0) {\n          return null;\n        }\n\n        return Validators.compose(VALIDATORS.map(\n        /**\n        * @param {?} opt\n        * @return {?}\n        */\n        opt =>\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const value = field.templateOptions[opt];\n\n          switch (opt) {\n            case 'required':\n              return Validators.required(control);\n\n            case 'pattern':\n              return Validators.pattern(value)(control);\n\n            case 'minLength':\n              return Validators.minLength(value)(control);\n\n            case 'maxLength':\n              return Validators.maxLength(value)(control);\n\n            case 'min':\n              return Validators.min(value)(control);\n\n            case 'max':\n              return Validators.max(value)(control);\n          }\n        }))(control);\n      }\n    );\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} validator\n   * @param {?=} validatorName\n   * @return {?}\n   */\n\n\n  wrapNgValidatorFn(field, validator, validatorName) {\n    /** @type {?} */\n    let validatorOption = null;\n\n    if (typeof validator === 'string') {\n      validatorOption = clone(this.formlyConfig.getValidator(validator));\n    }\n\n    if (typeof validator === 'object' && validator.name) {\n      validatorOption = clone(this.formlyConfig.getValidator(validator.name));\n\n      if (validator.options) {\n        validatorOption.options = validator.options;\n      }\n    }\n\n    if (typeof validator === 'object' && validator.expression) {\n      const {\n        expression\n      } = validator,\n            options = __rest(validator, [\"expression\"]);\n\n      validatorOption = {\n        name: validatorName,\n        validation: expression,\n        options: Object.keys(options).length > 0 ? options : null\n      };\n    }\n\n    if (typeof validator === 'function') {\n      validatorOption = {\n        name: validatorName,\n        validation: validator\n      };\n    }\n\n    return (\n      /**\n      * @param {?} control\n      * @return {?}\n      */\n      control => {\n        /** @type {?} */\n        const errors = validatorOption.validation(control, field, validatorOption.options);\n\n        if (isPromise(errors)) {\n          return errors.then(\n          /**\n          * @param {?} v\n          * @return {?}\n          */\n          v => this.handleAsyncResult(field, validatorName ? !!v : v, validatorOption));\n        }\n\n        if (isObservable(errors)) {\n          return errors.pipe(map(\n          /**\n          * @param {?} v\n          * @return {?}\n          */\n          v => this.handleAsyncResult(field, validatorName ? !!v : v, validatorOption)));\n        }\n\n        return this.handleResult(field, validatorName ? !!errors : errors, validatorOption);\n      }\n    );\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} errors\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  handleAsyncResult(field, errors, options) {\n    // workaround for https://github.com/angular/angular/issues/13200\n    if (field.options && field.options._markForCheck) {\n      field.options._markForCheck(field);\n    }\n\n    return this.handleResult(field, errors, options);\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @param {?} errors\n   * @param {?} __2\n   * @return {?}\n   */\n\n\n  handleResult(field, errors, {\n    name,\n    options\n  }) {\n    if (typeof errors === 'boolean') {\n      errors = errors ? null : {\n        [name]: options ? options : true\n      };\n    }\n    /** @type {?} */\n\n\n    const ctrl = field.formControl;\n    ctrl['_childrenErrors'] && ctrl['_childrenErrors'][name] && ctrl['_childrenErrors'][name]();\n\n    if (isObject(errors)) {\n      Object.keys(errors).forEach(\n      /**\n      * @param {?} name\n      * @return {?}\n      */\n      name => {\n        /** @type {?} */\n        const errorPath = errors[name].errorPath ? errors[name].errorPath : (options || {}).errorPath;\n        /** @type {?} */\n\n        const childCtrl = errorPath ? field.formControl.get(errorPath) : null;\n\n        if (childCtrl) {\n          const _a = errors[name],\n                opts = __rest(_a, [\"errorPath\"]);\n\n          childCtrl.setErrors(Object.assign({}, childCtrl.errors || {}, {\n            [name]: opts\n          }));\n          !ctrl['_childrenErrors'] && defineHiddenProp(ctrl, '_childrenErrors', {});\n\n          ctrl['_childrenErrors'][name] =\n          /**\n          * @return {?}\n          */\n          () => {\n            const _a = childCtrl.errors || {},\n                  _b = name,\n                  toDelete = _a[_b],\n                  childErrors = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n            childCtrl.setErrors(Object.keys(childErrors).length === 0 ? null : childErrors);\n          };\n        }\n      });\n    }\n\n    return errors;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nclass FieldFormExtension {\n  /**\n   * @param {?} config\n   */\n  constructor(config) {\n    this.config = config;\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  onPopulate(field) {\n    if (!field.parent) {\n      return;\n    }\n\n    if (field.fieldGroup && !field.key) {\n      defineHiddenProp(field, 'formControl', field.parent.formControl);\n    } else {\n      this.addFormControl(field);\n    }\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  postPopulate(field) {\n    if (field.parent) {\n      return;\n    }\n    /** @type {?} */\n\n\n    const fieldsToUpdate = this.setValidators(field);\n\n    if (fieldsToUpdate.length === 0) {\n      return;\n    }\n\n    if (fieldsToUpdate.length === 1) {\n      /** @type {?} */\n      let control = fieldsToUpdate[0].formControl;\n\n      while (control) {\n        /** @type {?} */\n        control._updateTreeValidity({\n          onlySelf: true\n        });\n\n        control = control.parent;\n      }\n    } else {\n      /** @type {?} */\n      field.formControl._updateTreeValidity();\n    }\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  addFormControl(field) {\n    /** @type {?} */\n    let control = findControl(field);\n\n    if (!control) {\n      /** @type {?} */\n      const controlOptions = {\n        updateOn: field.modelOptions.updateOn\n      };\n      /** @type {?} */\n\n      const value = field.key ? getFieldValue(field) : field.defaultValue;\n      /** @type {?} */\n\n      const ref = this.config ? this.config.resolveFieldTypeRef(field) : null;\n\n      if (ref && ref.componentType && ref.componentType['createControl']) {\n        /** @type {?} */\n        const component = ref.componentType;\n        console.warn(`NgxFormly: '${component.name}::createControl' is deprecated since v5.0, use 'prePopulate' hook instead.`);\n        control = component['createControl'](value, field);\n      } else if (field.fieldGroup) {\n        // TODO: move to postPopulate\n        control = new FormGroup({}, controlOptions);\n      } else {\n        control = new FormControl(value, controlOptions);\n      }\n    }\n\n    registerControl(field, control);\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  setValidators(field) {\n    /** @type {?} */\n    let updateValidity$$1 = false;\n\n    if (field.key || !field.parent || !field.key && !field.fieldGroup) {\n      const {\n        formControl: c\n      } = field;\n      /** @type {?} */\n\n      const disabled = field.templateOptions ? field.templateOptions.disabled : false;\n\n      if (field.key && c) {\n        if (disabled && c.enabled) {\n          c.disable({\n            emitEvent: false,\n            onlySelf: true\n          });\n\n          if (!c.parent) {\n            updateValidity(c);\n          } else {\n            updateValidity$$1 = true;\n          }\n        }\n\n        if (!disabled && c.disabled) {\n          c.enable({\n            emitEvent: false,\n            onlySelf: true\n          });\n\n          if (!c.parent) {\n            updateValidity(c);\n          } else {\n            updateValidity$$1 = true;\n          }\n        }\n      }\n\n      if (c && (null === c.validator || null === c.asyncValidator)) {\n        c.setValidators(\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const v = Validators.compose(this.mergeValidators(field, '_validators'));\n          return v ? v(c) : null;\n        });\n        c.setAsyncValidators(\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const v = Validators.composeAsync(this.mergeValidators(field, '_asyncValidators'));\n          return v ? v(c) : of(null);\n        });\n\n        if (!c.parent) {\n          updateValidity(c);\n        } else {\n          updateValidity$$1 = true;\n        }\n      }\n    }\n    /** @type {?} */\n\n\n    const fieldsToUpdate = updateValidity$$1 ? [field] : [];\n    (field.fieldGroup || []).forEach(\n    /**\n    * @param {?} f\n    * @return {?}\n    */\n    f => {\n      /** @type {?} */\n      const childrenToUpdate = this.setValidators(f);\n\n      if (!updateValidity$$1) {\n        fieldsToUpdate.push(...childrenToUpdate);\n      }\n    });\n    return fieldsToUpdate;\n  }\n  /**\n   * @private\n   * @template T\n   * @param {?} field\n   * @param {?} type\n   * @return {?}\n   */\n\n\n  mergeValidators(field, type) {\n    /** @type {?} */\n    const validators = [];\n    /** @type {?} */\n\n    const c = field.formControl;\n\n    if (c && c['_fields'] && c['_fields'].length > 1) {\n      c['_fields'].filter(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => !f._hide).forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => validators.push(...f[type]));\n    } else if (field[type]) {\n      validators.push(...field[type]);\n    }\n\n    if (field.fieldGroup) {\n      field.fieldGroup.filter(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => !f.key && f.fieldGroup).forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      f => validators.push(...this.mergeValidators(f, type)));\n    }\n\n    return validators;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nclass CoreExtension {\n  /**\n   * @param {?} formlyConfig\n   */\n  constructor(formlyConfig) {\n    this.formlyConfig = formlyConfig;\n    this.formId = 0;\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  prePopulate(field) {\n    this.getFieldComponentInstance(field).prePopulate();\n\n    if (field.parent) {\n      return;\n    }\n    /** @type {?} */\n\n\n    const fieldTransforms = field.options && field.options.fieldTransform || this.formlyConfig.extras.fieldTransform;\n    (Array.isArray(fieldTransforms) ? fieldTransforms : [fieldTransforms]).forEach(\n    /**\n    * @param {?} fieldTransform\n    * @return {?}\n    */\n    fieldTransform => {\n      if (fieldTransform) {\n        console.warn(`NgxFormly: fieldTransform is deprecated since v5.0, use custom extension instead.`);\n        /** @type {?} */\n\n        const fieldGroup = fieldTransform(field.fieldGroup, field.model,\n        /** @type {?} */\n        field.formControl, field.options);\n\n        if (!fieldGroup) {\n          throw new Error('fieldTransform must return an array of fields');\n        }\n      }\n    });\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  onPopulate(field) {\n    this.initFieldOptions(field);\n    this.getFieldComponentInstance(field).onPopulate();\n\n    if (field.fieldGroup) {\n      field.fieldGroup.forEach(\n      /**\n      * @param {?} f\n      * @param {?} index\n      * @return {?}\n      */\n      (f, index) => {\n        Object.defineProperty(f, 'parent', {\n          get:\n          /**\n          * @return {?}\n          */\n          () => field,\n          configurable: true\n        });\n        Object.defineProperty(f, 'index', {\n          get:\n          /**\n          * @return {?}\n          */\n          () => index,\n          configurable: true\n        });\n        this.formId++;\n      });\n    }\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  postPopulate(field) {\n    this.getFieldComponentInstance(field).postPopulate();\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  initFieldOptions(field) {\n    /** @type {?} */\n    const root =\n    /** @type {?} */\n    field.parent;\n\n    if (!root) {\n      return;\n    }\n\n    Object.defineProperty(field, 'form', {\n      get:\n      /**\n      * @return {?}\n      */\n      () => root.formControl,\n      configurable: true\n    });\n    Object.defineProperty(field, 'options', {\n      get:\n      /**\n      * @return {?}\n      */\n      () => root.options,\n      configurable: true\n    });\n    Object.defineProperty(field, 'model', {\n      get:\n      /**\n      * @return {?}\n      */\n      () => field.key && field.fieldGroup ? getFieldValue(field) : root.model,\n      configurable: true\n    });\n    reverseDeepMerge(field, {\n      id: getFieldId(`formly_${this.formId}`, field, field['index']),\n      hooks: {},\n      modelOptions: {},\n      templateOptions: !field.type || !field.key ? {} : {\n        label: '',\n        placeholder: '',\n        focus: false,\n        disabled: false\n      }\n    });\n\n    if (this.formlyConfig.extras.resetFieldOnHide && field.resetOnHide !== false) {\n      field.resetOnHide = true;\n    }\n\n    if (field.lifecycle) {\n      console.warn(`NgxFormly: 'lifecycle' is deprecated since v5.0, use 'hooks' instead.`);\n    }\n\n    if (field.type !== 'formly-template' && (field.template || field.expressionProperties && field.expressionProperties.template)) {\n      if (field.type) {\n        console.warn(`NgxFormly: passing 'type' property is not allowed when 'template' is set.`);\n      }\n\n      field.type = 'formly-template';\n    }\n\n    if (!field.type && field.fieldGroup) {\n      field.type = 'formly-group';\n    }\n\n    if (field.type) {\n      this.formlyConfig.getMergedField(field);\n    }\n\n    if (field.parent) {\n      /** @type {?} */\n      let setDefaultValue = !isUndefined(field.key) && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field)) && (!field.resetOnHide || !(field.hide || field.hideExpression));\n\n      if (setDefaultValue && field.resetOnHide) {\n        /** @type {?} */\n        let parent = field.parent;\n\n        while (parent && !parent.hideExpression && !parent.hide) {\n          parent = parent.parent;\n        }\n\n        setDefaultValue = !parent || !(parent.hideExpression || parent.hide);\n      }\n\n      if (setDefaultValue) {\n        assignFieldValue(field, field.defaultValue);\n      }\n    }\n\n    this.initFieldWrappers(field);\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  initFieldWrappers(field) {\n    field.wrappers = field.wrappers || [];\n    /** @type {?} */\n\n    const fieldTemplateManipulators = Object.assign({\n      preWrapper: [],\n      postWrapper: []\n    }, field.templateOptions.templateManipulators || {});\n    field.wrappers = [...this.formlyConfig.templateManipulators.preWrapper.map(\n    /**\n    * @param {?} m\n    * @return {?}\n    */\n    m => m(field)), ...fieldTemplateManipulators.preWrapper.map(\n    /**\n    * @param {?} m\n    * @return {?}\n    */\n    m => m(field)), ...field.wrappers, ...this.formlyConfig.templateManipulators.postWrapper.map(\n    /**\n    * @param {?} m\n    * @return {?}\n    */\n    m => m(field)), ...fieldTemplateManipulators.postWrapper.map(\n    /**\n    * @param {?} m\n    * @return {?}\n    */\n    m => m(field))].filter(\n    /**\n    * @param {?} el\n    * @param {?} i\n    * @param {?} a\n    * @return {?}\n    */\n    (el, i, a) => el && i === a.indexOf(el));\n  }\n  /**\n   * @private\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  getFieldComponentInstance(field) {\n    /** @type {?} */\n    const componentRef = this.formlyConfig.resolveFieldTypeRef(field);\n    /** @type {?} */\n\n    const instance = componentRef ?\n    /** @type {?} */\n    componentRef.instance : {};\n    return {\n      prePopulate:\n      /**\n      * @return {?}\n      */\n      () => instance.prePopulate && instance.prePopulate(field),\n      onPopulate:\n      /**\n      * @return {?}\n      */\n      () => instance.onPopulate && instance.onPopulate(field),\n      postPopulate:\n      /**\n      * @return {?}\n      */\n      () => instance.postPopulate && instance.postPopulate(field)\n    };\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} formlyConfig\n * @return {?}\n */\n\n\nfunction defaultFormlyConfig(formlyConfig) {\n  return {\n    types: [{\n      name: 'formly-group',\n      component: FormlyGroup\n    }, {\n      name: 'formly-template',\n      component: FormlyTemplateType\n    }],\n    extensions: [{\n      name: 'core',\n      extension: new CoreExtension(formlyConfig)\n    }, {\n      name: 'field-validation',\n      extension: new FieldValidationExtension(formlyConfig)\n    }, {\n      name: 'field-form',\n      extension: new FieldFormExtension(formlyConfig)\n    }, {\n      name: 'field-expression',\n      extension: new FieldExpressionExtension()\n    }]\n  };\n}\n\nlet FormlyModule = /*#__PURE__*/(() => {\n  class FormlyModule {\n    /**\n     * @param {?} configService\n     * @param {?=} configs\n     */\n    constructor(configService, configs = []) {\n      if (!configs) {\n        return;\n      }\n\n      configs.forEach(\n      /**\n      * @param {?} config\n      * @return {?}\n      */\n      config => configService.addConfig(config));\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    static forRoot(config = {}) {\n      return {\n        ngModule: FormlyModule,\n        providers: [{\n          provide: FORMLY_CONFIG,\n          multi: true,\n          useFactory: defaultFormlyConfig,\n          deps: [FormlyConfig]\n        }, {\n          provide: FORMLY_CONFIG,\n          useValue: config,\n          multi: true\n        }, {\n          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n          useValue: config,\n          multi: true\n        }, FormlyConfig, FormlyFormBuilder]\n      };\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    static forChild(config = {}) {\n      return {\n        ngModule: FormlyModule,\n        providers: [{\n          provide: FORMLY_CONFIG,\n          multi: true,\n          useFactory: defaultFormlyConfig,\n          deps: [FormlyConfig]\n        }, {\n          provide: FORMLY_CONFIG,\n          useValue: config,\n          multi: true\n        }, {\n          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n          useValue: config,\n          multi: true\n        }, FormlyFormBuilder]\n      };\n    }\n\n  }\n\n  FormlyModule.ɵfac = function FormlyModule_Factory(t) {\n    return new (t || FormlyModule)(ɵngcc0.ɵɵinject(FormlyConfig), ɵngcc0.ɵɵinject(FORMLY_CONFIG, 8));\n  };\n\n  FormlyModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: FormlyModule\n  });\n  FormlyModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  /** @nocollapse */\n\n  return FormlyModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormlyModule, {\n    declarations: function () {\n      return [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage, FormlyTemplateType, FieldArrayType];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { FormlyForm, FormlyField, FormlyAttributes, FORMLY_CONFIG, FormlyConfig, FormlyFormBuilder, FieldType, Field, FieldArrayType, FieldWrapper, FormlyModule, defineHiddenProp as ɵdefineHiddenProp, reverseDeepMerge as ɵreverseDeepMerge, getFieldInitialValue as ɵgetFieldInitialValue, clone as ɵclone, wrapProperty as ɵwrapProperty, defaultFormlyConfig as ɵa, CoreExtension as ɵe, FieldExpressionExtension as ɵh, FieldFormExtension as ɵg, FieldValidationExtension as ɵf, FormlyTemplateType as ɵd, FormlyGroup as ɵb, FormlyValidationMessage as ɵc }; //# sourceMappingURL=ngx-formly-core.js.map","map":null,"metadata":{},"sourceType":"module"}